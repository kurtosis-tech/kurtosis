---
title: How do idempotent runs work?
sidebar_label: How do idempotent runs work?
---

Background
----------
:::tip
To learn about what idempotent runs are in Kurtosis and the motivation behind this feature, go [here][idempotent-run-concept-reference].
:::

When running the `kurtosis run` command, you may notice the following message get printed:
```console
SKIPPED - This instruction has already been run in this enclave
```
The reason this happens is because Kurtosis will optimize each run of a Starlark package based on what has already been 
run in a given enclave, thus reducing execution time and resources.

This means when you try to run the exact same package twice in a row, Kurtosis will skip all the instructions for the 
second run because they were already executed in the first run.

:::info
This feature is still experimental and can be deactivated by adding `--experimental NO_INSTRUCTIONS_CACHING` parameter 
to the `kurtosis run` command.
:::

How it works
------------

#### Definitions

The __enclave plan__ is defined as the sequence of Starlark instructions that were previously executed inside a given 
enclave. Meanwhile, the __submitted plan__ is defined as the set of instructions generated by interpreting the package 
before it gets executed.

When running a Starlark package in a world without idempotent runs, all the instructions are naively executed inside 
the enclave and the new _post-execution enclave plan_ is set to the concatenation of the previous _enclave plan_ and 
the _submitted plan_.

To avoid re-running instructions that have already been run inside the enclave, Kurtosis will try to maximize the 
overlap __between the submitted plan and the tail-end portion of the enclave plan__. In the overlapping portion, 
if any, Kurtosis will re-run only the instructions that were updated. Then, if they are new instructions at the end 
of the _submitted plan_ that were not in the _enclave plan_, they are executed as new instructions and added to the 
_enclave plan_

#### Instruction equality 

To spot overlap between the _enclave plan_ and the _submitted plan_, Kurtosis needs to compare instructions one by one. 
There are different level of equality:
- The submitted plan instruction is __equal__ to the enclave plan instruction - the instructions are of the same type 
(i.e. two `exec`, `wait`, `upload_file` etc.) __and__ the set of arguments of the instructions are strictly identical.
- The submitted plan instruction is __an update of__ the enclave plan instruction - the instructions are of the same 
type but only a subset of pre-defined arguments are identical. This only exist for a certain instructions:
  - `add_service` instruction adding a service with __the same name__ but a different `ServiceConfig` object will be 
  considered as an update to the enclave plan instruction. The service will be restarted inside the enclave with the 
  new service configuration. 
  - `upload_file` instruction uploading a files artifact with __the same name__ but different file contents will be 
  considered as an update to the enclave plan instruction. The files artifact will be updated with the new contents 
  inside the enclave.
  - `render_template` instruction creating a files artifact with _the same name_ but a different content will be 
  considered as an update to the enclave plan instruction. Similarly to `upload_file`, the content of the files artifact 
  will be updated inside the enclave.
  - `store_service_file` instruction creating a files artifact with _the same name_ but either a different source path 
  or a different service name will be considered as an update to the enclave plan instruction. Similarly to 
  `upload_file`, the content of the files artifact will be updated inside the enclave.

Two instructions that doesn't fit into any of the two categories above are considered __different__ (i.e. independent 
from each other).

It's good to callout here that a few Kurtosis instructions are __fundamentally incompatible with the concept of 
idempotency__. The use of one of those instructions in the package will make the plans not resolvable, and Kurtosis will 
default to the "naive" execution strategy of running the _submitted plan_ on top of the _current plan_, without even 
trying the overlap them. Those instructions currently are:
- `remove_service`
- `start_service`
- `stop_service`

#### Instruction dependencies

Certain instructions depend on other ones, and with the concept of __instruction update__ explained above comes the 
concept of __dependency between instructions__. It's easier to understand the concept with an example. 

Let's consider a submitted plan with 2 instructions: an `add_service` adding `service_1` and an `exec` on  `service_1`. 
If the first `add_service` instruction is considered an update when running the package, `service_1` will be updated 
and therefore restarted. In that case, __even if the `exec` is equal to the matching instruction in the enclave plan__ 
it will be re-run because it runs on a component (`service_1`) that has been updated. It is said that the `exec` 
instruction depends on the `add_service` instruction.

Dependency relationships can be the following:
- `add_service` instruction depends on the files artifact mounted onto the service. If one of the files artifact is 
updated, the `add_service` will be re-run 
- `exec` instruction depends on the service on which it runs. If the service is updated, the `exec` will be re-run.
- `request` instruction depends on the service on which it runs, similarly to `exec` 
- `store_service_file`instruction depends on the service on which it runs, similarly to `exec`
- `wait` instruction depends on the service on which it runs, similarly to `exec`

Examples
--------

#### Case of a _submitted plan_ being disjoint from the _enclave plan_
No instruction get skipped, all instructions from the _submitted plan_ are executed and appended to the _enclave plan_.

![disjoint-plans-v2.png](/img/advanced-concepts/starlark-idempotent-run/disjoint-plans-v2.png)

#### Case of a _submitted plan_ partially overlapping the _enclave plan_
The first two `add_service` instructions from the submitted plans are __equal__ to the last two instructions of the 
enclave plan. They are therefore skipped, and only the `exec` and `store_service_files` from the submitted plan are
executed.

![overlapping-plans-v2.png](/img/advanced-concepts/starlark-idempotent-run/overlapping-plans-v2.png)

#### Case of a _submitted plan_ partially overlapping the _enclave plan_ with instruction updates
The `upload_file` instruction is equal, it will be skipped similarly to the case explained above.

The `add_service` instruction from the submitted plan adding service `service_1` __is an update__ of the `add_service`
instruction from the enclave plan adding `service_1` (notice the `***` on the schema - the `ServiceConfig` object has 
been updated, for example to update the container image version). It will therefore be re-run and `service_1` will 
be updated inside the enclave.

The second `add_service` instruction from the submitted plan adding service `service_2` is __equal__ to the one
from the enclave plan. It will be skipped.

The `exec` instruction from the submitted plan is __equal__ to the one from the enclave plan. However, since
it operates on `service_1` __and__ `service_1` was updated in the submitted plan, this instruction __will also be 
re-run__.

The `store_service_file` from the submitted plan is __equal__ to the one from the enclave plan, and the service on 
which it runs (`service_2`) was left intact in the submitted plan. It will therefore be skipped.

![overlapping-plans-with-updates-v2.png](/img/advanced-concepts/starlark-idempotent-run/overlapping-plans-with-updates-v2.png)

<!---------------------------------- REFERENCE LINKS ---------------------------------------------------------->
[idempotent-run-concept-reference]: ../advanced-concepts/idempotent-runs.md

