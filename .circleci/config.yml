##############
# Yaml Anchors
##############
# Don't run cli jobs on  main branches
filters_ignore_main: &filters_ignore_main
  filters:
    branches:
      ignore:
        - main

# Don't run on tags
filters_ignore_tags: &filters_ignore_tags
  filters:
    branches:
      ignore: /.*/
    tags:
      only: /^[0-9]+\.[0-9]+\.[0-9]+$/

# cli cluster param used to run test suites against docker/kubernetes tests
param_cli_cluster_backend: &param_cli_cluster_backend
  cli-cluster-backend:
    description: "Kurtosis cluster backend for the cli to use. Must be one of 'docker', 'kubernetes'"
    type: enum
    enum: ["docker", "kubernetes"]

# Install go version to run our integration tests on the minimal version we support
steps_install_go: &steps_install_go
  - run: |
      wget https://go.dev/dl/go<< pipeline.parameters.go-version >>.linux-amd64.tar.gz
      sudo rm -rf /usr/local/go
      sudo tar -C /usr/local -xzf go<< pipeline.parameters.go-version >>.linux-amd64.tar.gz

# Steps to prepare a job for Kubernetes testing (with K3S K8S distribution)
steps_prepare_testing_k8s_k3s: &steps_prepare_testing_k8s_k3s
  steps:
    - run:
        name: Install K3D and create the K3D/K3S cluster on Docker
        command: |
          curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
          k3d cluster create -p "<< pipeline.parameters.reverse-proxy-entrypoint-web-port >>:80@loadbalancer" --servers 1 --wait --verbose

    - run:
        name: Load Kurtosis images into the K3S cluster
        # First load the image into Docker and then import the images into K3S by taking the image from Docker
        command: |
          kurtosis_version="$(./scripts/get-docker-tag.sh)"

          docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.core-server-image-filename >>"

          docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.engine-server-image-filename >>"

          docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.file-artifacts-expander-image-filename >>"

          k3d image import "kurtosistech/core:$kurtosis_version" "kurtosistech/engine:$kurtosis_version" "kurtosistech/files-artifacts-expander:$kurtosis_version"
    # Edit the Kurtosis config file in order to have K3S cluster configuration
    - run:
        name: Add K3S cluster config in Kurtosis config file
        command: |
          KURTOSIS_CONFIG_FILEPATH=$($KURTOSIS_BINPATH config path)
          cat \<< EOF > "$KURTOSIS_CONFIG_FILEPATH"
          config-version: 2
          should-send-metrics: true
          kurtosis-clusters:
            docker:
              type: docker
            k3d-k3s-default:
              type: kubernetes
              config:
                kubernetes-cluster-name: k3d-k3s-default
                storage-class: local-path
                enclave-size-in-megabytes: 2048
          EOF
    # Set the K3S cluster with some previous steps to force this cluster type in the cluster-setting file. This save us to start the engine with the cluster set command
    # because we are going to start it on the next step
    - run:
        name: Set K3S Kurtosis cluster
        command: |
          KURTOSIS_CLUSTER_SETTING_FILEPATH="<< pipeline.parameters.kurtosis-cluster-setting-abs-filepath >>"
          echo -n "k3d-k3s-default" > "$KURTOSIS_CLUSTER_SETTING_FILEPATH"
          echo "Kurtosis cluster-setting file content: $(cat $KURTOSIS_CLUSTER_SETTING_FILEPATH)"
          ${KURTOSIS_BINPATH} cluster set k3d-k3s-default --cli-log-level trace
    - run:
        name: Start Kurtosis engine in K8s backend
        command: |
          ${KURTOSIS_BINPATH} engine start --cli-log-level=debug --enclave-pool-size 2
    - run:
        name: Run Kurtosis gateway
        command: "${KURTOSIS_BINPATH} gateway"
        background: true

run_prepare_testing_docker: &run_prepare_testing_docker
  - run:
      name: Load the engine, apic and file artifacts images and start the engine
      command: |
        docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.core-server-image-filename >>"
        docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.engine-server-image-filename >>"
        docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.file-artifacts-expander-image-filename >>"
        ${KURTOSIS_BINPATH} engine start --cli-log-level trace

# Steps to prepare a job for Docker testing
steps_prepare_testing_docker: &steps_prepare_testing_docker
  steps:
    - <<: *run_prepare_testing_docker

# Run steps to dump kurtosis enclaves from docker
run_dump_kurtosis_enclaves: &run_dump_kurtosis_enclaves
  run: |
    cd /tmp
    output_dirname="enclave-dumps"
    mkdir "${output_dirname}"

    # We exclude "WARN" and "INFO" messages because otherwise they'll pollute the STDOUT grab
    # We can remove this tedious exclusion when https://github.com/kurtosis-tech/kurtosis/issues/399 is implemented
    for enclave_uuid in $("${KURTOSIS_BINPATH}" enclave ls | grep -v "WARN" | grep -v "INFO" | grep -v "UUID" | awk '{print $1}'); do
      "${KURTOSIS_BINPATH}" enclave dump "${enclave_uuid}" "${output_dirname}/${enclave_uuid}"
    done

    # Verify that we actually dumped enclaves by ensuring the number of dumped enclaves is greater than 0 (if not, it's a bug in this dumping logic)
    num_dumped_enclaves="$(find "${output_dirname}" -mindepth 1 -maxdepth 1 -type d | wc -l)"
    [ "${num_dumped_enclaves}" -gt 0 ]

    zip -r "${output_dirname}.zip" "${output_dirname}"

# If the only changes are to the docs subdirectory or to Markdown files, we can optimize and skip any code-building/code-testing
# `git diff --exit-code` returns 0 exit code if no changes, and 1 if changes
abort_job_if_only_docs_changes: &abort_job_if_only_docs_changes
  run: |
    if git --no-pager diff --exit-code origin/main...HEAD -- . ':!docs' ':!*.md'; then
      circleci-agent step halt
    fi

abort_job_if_kubernetes_backend: &abort_job_if_kubernetes_backend
  when:
    condition:
      equal: ["kubernetes", << parameters.cli-cluster-backend >>]
    steps:
      - run: circleci-agent step halt

abort_job: &abort_job
  run: circleci-agent step halt

##############
# CircleCI
##############
version: 2.1

orbs:
  npm-publisher: uraway/npm-publisher@0.2.0
  kurtosis-docs-checker: kurtosis-tech/docs-checker@0.2.10
  slack: circleci/slack@4.10.1

executors:
  ubuntu_vm:
    machine:
      # This custom CircleCi Ubuntu image has a pre-installed Docker, so we are not using the CircleCI remote Docker when we
      # initiate this machine. More here: https://discuss.circleci.com/t/linux-machine-executor-images-2022-january-q1-update/42831
      image: ubuntu-2004:2023.10.1

parameters:
  go-version:
    type: string
    default: "1.23.7"
  container-engine-lib-build-cache-key-prefix:
    type: string
    default: "go-mod-v1" # Can bump this version to bust the cache
  # To upgrade the Docker Engine version, see which versions are supported at: https://circleci.com/docs/remote-docker-images-support-policy/
  docker-engine-version:
    type: string
    default: default
  api-go-version:
    type: string
    default: "1.23.7"
  # Separate (and newer) than the API version because we want lots of people to be able to use the Kurtosis API and the API doesn't need to be
  # the same version as the server
  rust-version:
    type: string
    default: 1.88.0
  api-node-version:
    type: string
    default: 16.13.0
  ui-node-version:
    type: string
    default: 18.19.0
  core-server-build-cache-key-prefix:
    type: string
    default: "core-server-go-mod-v1" # Can bump this version to bust the cache
  engine-server-build-cache-key-prefix:
    type: string
    default: "engine-server-go-mod-v1" # Can bump this version to bust the cache
  workspace-with-cli-binary-and-images-mountpoint:
    type: string
    default: "/tmp/workspace"
  # The dirpath where CLI dist subdirectories are found, relative to the workspace root
  cli-dist-home-relative-dirpath:
    type: string
    default: "cli/cli/dist"
  # The filepath where the Linux AMD 64 CLI binary can be found, relative to the cli-dist-home-relative-dirpath
  cli-linux-amd-64-binary-relative-filepath:
    type: string
    default: "cli_linux_amd64_v1/kurtosis"
  # The key that the CLI build cache will get
  # We can bump the version here if we ever need to bust the cache
  cli-build-cache-key-prefix:
    type: string
    default: "cli-go-mod-v2"
  generate-kurtosis-version-script-path:
    type: string
    default: "scripts/generate-kurtosis-version.sh"
  core-server-image-filename:
    type: string
    default: "core-server-image.tgz"
  file-artifacts-expander-image-filename:
    type: string
    default: "file-artifacts-expander-image.tgz"
  enclave-manager-yarn-cache-key-prefix:
    type: string
    default: "enclave-manager_yarn"
  engine-server-image-filename:
    type: string
    default: "engine-server-image.tgz"
  startosis-test-script-file-relative-path:
    type: string
    default: "internal_testsuites/starlark/ci_tests/simple_no_arg_test/startosis_simple_script.star"
  starlark-test-args-file-test-main-star-relative-path:
    type: string
    default: "internal_testsuites/starlark/ci_tests/simple_arg_test/main.star"
  starlark-test-taints-and-tolerations:
    type: string
    default: "internal_testsuites/starlark/taints_and_tolerations/taints_and_toleration_test.star"
  starlark-test-args-file-test-args-json-relative-path:
    type: string
    default: "internal_testsuites/starlark/ci_tests/simple_arg_test/args.json"
  starlark-test-args-file-url:
    type: string
    default: "https://raw.githubusercontent.com/kurtosis-tech/sample-startosis-load/main/args.json"
  rendertemplate-cli-test-template-relative-path:
    type: string
    default: "internal_testsuites/resources/render_template_cli_test/template.txt"
  dockerimport-cli-dotenv-relative-path:
    type: string
    default: "internal_testsuites/resources/docker_import_cli_test/.env"
  dockerimport-cli-dockerfile-relative-path:
    type: string
    default: "internal_testsuites/resources/docker_import_cli_test/docker-compose.yml"
  rendertemplate-cli-test-data-json-relative-path:
    type: string
    default: "internal_testsuites/resources/render_template_cli_test/data.json"
  kurtosis-cluster-setting-abs-filepath:
    type: string
    default: "/home/circleci/.local/share/kurtosis/cluster-setting"
  reverse-proxy-entrypoint-web-port:
    type: string
    default: "9730"
  tilt-releaser-version:
    type: string
    default: "9d05f87976ccdf8a3434443fac2b867ca99a81c8423008437c767c04784969e4"

# NOTE: Because CircleCI jobs run on separate machines from each other, we duplicate steps (like checkout) between jobs. This is because doing the "correct" DRY
#  refactoring of, "one job for checkout, one job for build Docker image, etc." would require a) persisting files between jobs and b) persisting Docker images between
#  jobs. Both are annoying (saving/loading workspaces require re-downloading the workspace over the network, and there doesn't seem to be a good way to do Docker
#  images), so we run everything inside a single job.
# See also: https://discuss.circleci.com/t/can-docker-images-be-preserved-between-jobs-in-a-workflow-without-a-manual-load-save/23388/12
jobs:
  # -- build jobs ------------------------------------------
  build_container_engine_lib:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"

    # Done on 2022-05-15, when the job was 1m30s and CircleCI insights showed that we were maxing out the 'medium' class CPUs
    resource_class: large

    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.container-engine-lib-build-cache-key-prefix >>-{{ checksum "container-engine-lib/go.sum" }}

      - run: |
          container-engine-lib/scripts/build.sh
      - save_cache:
          key: << pipeline.parameters.container-engine-lib-build-cache-key-prefix >>-{{ checksum "container-engine-lib/go.sum" }}
          paths:
            - "/home/circleci/go/pkg/mod" # Go module cache on the cimg/go image, as reported by "go env GOMODCACHE"
            - "/home/circleci/.cache/go-build" # Go build cache on the cimg/go image, as reported by "go env GOCACHE"

  build_contexts_config_store:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - checkout
      - <<: *abort_job_if_only_docs_changes
      - run: contexts-config-store/scripts/build.sh

  build_grpc_file_transfer:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version>>"
    steps:
      - checkout
      - <<: *abort_job_if_only_docs_changes
      - run: grpc-file-transfer/scripts/build.sh

  build_metrics_library:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version>>"
    steps:
      - checkout
      - <<: *abort_job_if_only_docs_changes
      - run: metrics-library/scripts/build.sh

  build_name_generator:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version>>"
    steps:
      - checkout
      - <<: *abort_job_if_only_docs_changes
      - run: name_generator/scripts/build.sh

  build_kurtosis_api_golang:
    docker:
      - image: "cimg/go:<< pipeline.parameters.api-go-version>>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # !!!!!!!!!! NOTE: We should NOT use our private Go repos here, because this API code will get published publicly !!!!!!!!
      - run: api/golang/scripts/build.sh

  build_kurtosis_api_typescript:
    docker:
      - image: "cimg/node:<< pipeline.parameters.api-node-version>>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      - run: api/typescript/scripts/build.sh

  build_files_artifacts_expander:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Generate Kurtosis Version
      - run: "<<pipeline.parameters.generate-kurtosis-version-script-path>>"

      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"

      - run: |
          core/files_artifacts_expander/scripts/build.sh
          source core/files_artifacts_expander/scripts/_constants.env
          version_to_publish="$(./scripts/get-docker-tag.sh)"
          image_name_with_version="${IMAGE_ORG_AND_REPO}:${version_to_publish}"
          echo "Version that will be persisted to workspace: ${version_to_publish}"
          docker save -o << pipeline.parameters.file-artifacts-expander-image-filename >> "${image_name_with_version}"

      - persist_to_workspace:
          root: .
          paths:
            - "<< pipeline.parameters.file-artifacts-expander-image-filename >>"
            - "<< pipeline.parameters.starlark-test-args-file-test-main-star-relative-path >>"
            - "<< pipeline.parameters.starlark-test-args-file-test-args-json-relative-path >>"
            - "<< pipeline.parameters.starlark-test-args-file-url >>"

  build_core_launcher:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Generate Kurtosis Version
      - run: "<<pipeline.parameters.generate-kurtosis-version-script-path>>"

      - run: |
          core/launcher/scripts/build.sh

  build_api_container_server:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Install proto compiler. To compile startosis proto files on the fly, the APIC needs `protoc`
      - run: |
          sudo apt update
          sudo apt install protobuf-compiler

      # Generate Kurtosis Version
      - run: "<<pipeline.parameters.generate-kurtosis-version-script-path>>"

      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.core-server-build-cache-key-prefix>>-{{ checksum "core/server/go.sum" }}

      - run: |
          core/server/scripts/build.sh
          source core/server/scripts/_constants.env
          version_to_publish="$(./scripts/get-docker-tag.sh)"
          image_name_with_version="${IMAGE_ORG_AND_REPO}:${version_to_publish}"
          echo "Version that will be persisted to workspace: ${version_to_publish}"
          docker save -o << pipeline.parameters.core-server-image-filename >> "${image_name_with_version}"

      - save_cache:
          key: << pipeline.parameters.core-server-build-cache-key-prefix>>-{{ checksum "core/server/go.sum" }}
          paths:
            - "/home/circleci/go/pkg/mod" # Go module cache on the cimg/go image, as reported by "go env GOMODCACHE"
            - "/home/circleci/.cache/go-build" # Go build cache on the cimg/go image, as reported by "go env GOCACHE"

      - persist_to_workspace:
          root: .
          paths:
            - "<< pipeline.parameters.core-server-image-filename >>"

  build_enclave_manager_webapp:
    executor: ubuntu_vm
    steps:
      - checkout

      - run: |
          # If the current commit is not a tag and if there is no change (compared to main) of anything but docs, then skip this
          if [ -z "${CIRCLE_TAG:-}" ] && git --no-pager diff --exit-code origin/main...HEAD -- . ':!docs' ':!*.md' ; then
            circleci-agent step halt
          fi

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.enclave-manager-yarn-cache-key-prefix>>-{{ checksum "enclave-manager/api/typescript/yarn.lock" }}-{{ checksum "enclave-manager/web/yarn.lock" }}

      - run: npm install -g yarn

      - run: |
          enclave-manager/scripts/build.sh

      - save_cache:
          key: << pipeline.parameters.enclave-manager-yarn-cache-key-prefix>>-{{ checksum "enclave-manager/api/typescript/yarn.lock" }}-{{ checksum "enclave-manager/web/yarn.lock" }}
          paths:
            - "/home/circleci/.cache/yarn"

      - persist_to_workspace:
          root: engine/server
          paths:
            - webapp

  build_engine_launcher:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Generate Kurtosis Version
      - run: "<<pipeline.parameters.generate-kurtosis-version-script-path>>"

      - run: |
          engine/launcher/scripts/build.sh

  build_engine_server:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - run: cp -R << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/webapp engine/server/webapp

      # Generate Kurtosis Version
      - run: "<<pipeline.parameters.generate-kurtosis-version-script-path>>"

      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.engine-server-build-cache-key-prefix>>-{{ checksum "engine/server/go.sum" }}

      - run: |
          engine/server/scripts/build.sh
          source engine/server/scripts/_constants.env
          version_to_publish="$(./scripts/get-docker-tag.sh)"
          image_name_with_version="${IMAGE_ORG_AND_REPO}:${version_to_publish}"
          echo "Version that will be persisted to workspace: ${version_to_publish}"
          docker save -o << pipeline.parameters.engine-server-image-filename >> "${image_name_with_version}"

      - save_cache:
          key: << pipeline.parameters.engine-server-build-cache-key-prefix>>-{{ checksum "engine/server/go.sum" }}
          paths:
            - "/home/circleci/go/pkg/mod" # Go module cache on the cimg/go image, as reported by "go env GOMODCACHE"
            - "/home/circleci/.cache/go-build" # Go build cache on the cimg/go image, as reported by "go env GOCACHE"

      - persist_to_workspace:
          root: .
          paths:
            - "<< pipeline.parameters.engine-server-image-filename >>"

  build_cli:
    # The starlark-lsp uses treesitter which has direct c bindings; and making a go releaser cross arch build
    # requires a lot of tooling; when the original author adding starlark-lsp to the project they copied the tilt-releaser
    # which came with all of the underlying tooling instead of bundling their own image; perhaps due to time constraints
    docker:
      - image: "docker/tilt-releaser@sha256:<< pipeline.parameters.tilt-releaser-version >>"
    resource_class: large
    parameters:
      all_architectures:
        description: "Whether we should build all architectures or not"
        type: boolean
        default: false
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      #- run: sudo apt-get update -y && sudo apt-get install -y musl-dev && sudo apt-get install -y gcc-aarch64-linux-gnu && sudo apt-get install -y g++-aarch64-linux-gnu

      # Generate Kurtosis Version
      - run: "<<pipeline.parameters.generate-kurtosis-version-script-path>>"

      # we need to update the apt key, otherwise imports fails due to unrecognized key
      - run: |
          curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.cli-build-cache-key-prefix >>-{{ checksum "cli/cli/go.sum" }}

      - run: |
          cli/cli/scripts/build.sh << parameters.all_architectures >>

      # only save cache and persist to workspace the CLI built for just the CircleCI architecture
      - when:
          condition:
            equal: [false, << parameters.all_architectures >>]
          steps:
            - save_cache:
                key: << pipeline.parameters.cli-build-cache-key-prefix >>-{{ checksum "cli/cli/go.sum" }}
                paths:
                  - "/go/pkg/mod" # Go module cache for the Goreleaser image, as reported by "go env GOMODCACHE"
                  - "/root/.cache/go-build" # Go build cache for the Goreleaser image, as reported by "go env GOCACHE"

            - persist_to_workspace:
                root: .
                paths:
                  - "./<< pipeline.parameters.cli-dist-home-relative-dirpath >>"
                  - "./<< pipeline.parameters.startosis-test-script-file-relative-path >>"
                  - "./<< pipeline.parameters.starlark-test-taints-and-tolerations >>"

  build_golang_testsuite:
    executor: ubuntu_vm
    parameters:
      <<: *param_cli_cluster_backend
    parallelism: 4
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - <<: *steps_install_go

      # We call Kurtosis a bunch later, so add it to the PATH so we can call it easily
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      #Run config init to avoid metrics consent prompt when execute engine start command,
      #We do not send metrics from CI to not dirty the metrics data
      - run: "${KURTOSIS_BINPATH} analytics disable"

      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_k8s_k3s

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_docker

      # Run the testsuite for kubernetes and docker, but don't fail the job immediately so that we can upload the enclave dump
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          steps:
            - run: |
                if ! ./internal_testsuites/golang/scripts/test.sh kubernetes true; then
                  touch /tmp/testsuite-failed
                fi

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            - run: |
                if ! ./internal_testsuites/golang/scripts/test.sh docker true; then
                  touch /tmp/testsuite-failed
                fi

      # TODO TODO TODO DELETE THIS HACK!!!!!
      # First reason (only for K8s):
      # As of 2022-11-18, 'enclave dump' in Kubernetes in CircleCI (but not locally) takes 30s to run per enclave, and "suceeds"
      # but without dumping anything! To avoid our CI runs getting an extra 15 minutes added on, we're only dumping enclaves in Docker
      # Second reason:
      # As of 2023-07-26, stop enclave calls were replaced by destroy enclave calls because doing so improve the velocity of the entire K8s test suite by 6min
      # We can't run enclave dumps if the the enclaves are not running at the moment, but we could enable it once the centralized logs feature is added on Kurtosis
      # because we could use enclave-dumps again (it will be calling the centralize logs component instead of getting the logs form the containers)

      # TODO UNCOMMENT THIS WHEN WE FIX THE BUG ABOVE!!!
      # Dump enclave data so we can debug any issues that arise
      # - <<: *run_dump_kurtosis_enclaves

      # TODO UNCOMMENT THIS WHEN WE FIX THE BUG ABOVE!!!
      #- store_artifacts:
      #    path: /tmp/enclave-dumps.zip
      #    destination: enclave-dumps.zip

      # Finally, fail the job if the testsuite failed
      - run: "! [ -f /tmp/testsuite-failed ]"

  build_typescript_testsuite:
    executor: ubuntu_vm
    parameters:
      <<: *param_cli_cluster_backend
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"
      # We call Kurtosis a bunch later, so add it to the PATH so we can call it easily
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"

      #Run install Yarn because TypeScript tests are managed with Yarn package manager
      - run: npm install -g yarn

      #Run config init to avoid metrics consent prompt when execute engine start command,
      #We do not send metrics from CI to not dirty the metrics data
      - run: "${KURTOSIS_BINPATH} analytics disable"
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_k8s_k3s

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_docker

      # Run the testsuite for either docker or kubernetes, but don't fail the job immediately so that we can upload the enclave dump
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          steps:
            - run: |
                if ! ./internal_testsuites/typescript/scripts/test.sh kubernetes; then
                   touch /tmp/testsuite-failed
                fi
      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            - run: |
                if ! ./internal_testsuites/typescript/scripts/test.sh; then
                   touch /tmp/testsuite-failed
                 fi

      # TODO TODO TODO DELETE THIS HACK!!!!!
      # As of 2022-11-18, 'enclave dump' in Kubernetes in CircleCI (but not locally) takes 30s to run per enclave, and "suceeds"
      # but without dumping anything! To avoid our CI runs getting an extra 15 minutes added on, we're only dumping enclaves in Docker
      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            <<: *run_dump_kurtosis_enclaves

      # TODO UNCOMMENT THIS WHEN WE FIX THE BUG ABOVE!!!
      # Dump enclave data so we can debug any issues that arise
      # - <<: *run_dump_kurtosis_enclaves

      - store_artifacts:
          path: /tmp/enclave-dumps.zip
          destination: enclave-dumps.zip
      - store_artifacts:
          path: /tmp/enclave-dumps.zip
          destination: enclave-dumps.zip

      # Finally, fail the job if the testsuite failed
      - run: "! [ -f /tmp/testsuite-failed ]"

  test_old_enclave_continuity:
    executor: ubuntu_vm
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - <<: *steps_install_go

      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli
      # We don't send metrics to avoid polluting our logs
      - run: kurtosis analytics disable

      # Start up an enclave with some services inside
      - run: kurtosis enclave add --name running-old-enclave
      - run: kurtosis enclave add --name stopped-old-enclave
      - run: kurtosis service add running-old-enclave test-datastore-one kurtosistech/example-datastore-server
      - run: kurtosis service add stopped-old-enclave test-datastore-two kurtosistech/example-datastore-server
      - run: kurtosis enclave stop stopped-old-enclave
      - run: kurtosis engine stop

      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
          docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.core-server-image-filename >>"
          docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.engine-server-image-filename >>"
          docker load -i  "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.file-artifacts-expander-image-filename >>"

      # Make sure we can still interact with the old enclaves
      - run: "${KURTOSIS_BINPATH} enclave ls"
      - run: "${KURTOSIS_BINPATH} enclave inspect running-old-enclave"
      - run: "${KURTOSIS_BINPATH} service add running-old-enclave test-service httpd --ports http=80"
      - run: "${KURTOSIS_BINPATH} enclave stop running-old-enclave"
      - run: "${KURTOSIS_BINPATH} enclave inspect stopped-old-enclave"

      # Ensure enclaves still work
      - run: "${KURTOSIS_BINPATH} clean -a"
      - run: "${KURTOSIS_BINPATH} engine stop"

      # Ensure everything got cleaned up successfully
      - run:
          name: "Verify only the engine container remains after the clean"
          command: |
            if ! [ "$(docker container ls -a | tail -n+2 | wc -l)" -eq 0 ]; then
              docker container ls -a
              false
            fi
      - run:
          name: "Verify Kurtosis cleaned up all its volumes (except for the log storage, logs aggregator data, github auth storage, docker auth config volumes)"
          command: |
            if ! [ $(docker volume ls | grep -v kurtosis-logs-collector-vol | grep -v kurtosis-logs-db-vol | tail -n+2 | wc -l ) -eq 4 ]; then
              docker volume ls
              false
            fi
      - run:
          name: "Verify Kurtosis cleaned up all its networks"
          command: |
            builtin_network_ids=(
              "$(docker network ls --quiet --filter "name=host")"
              "$(docker network ls --quiet --filter "name=bridge")"
              "$(docker network ls --quiet --filter "name=none")"
            )
            if ! [ $(docker network ls | grep -v -f <(printf "%s\n" "${builtin_network_ids[@]}") | tail -n+2 | wc -l) -eq 0 ]; then
              docker network ls
              false
            fi

  test_enclave_manager_web_ui:
    executor: ubuntu_vm
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli
      # We don't send metrics to avoid polluting our logs
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: "${KURTOSIS_BINPATH} analytics disable"
      - <<: *run_prepare_testing_docker

      - run: npm install -g yarn

      - run: enclave-manager/api/scripts/build.sh

      - run:
          command: yarn cleanInstall
          working_directory: enclave-manager/web

      - run:
          command: yarn cypress:ete
          working_directory: enclave-manager/web

      - store_artifacts:
          path: /home/circleci/project/enclave-manager/web/cypress/screenshots

  test_basic_cli_functionality:
    executor: ubuntu_vm
    parameters:
      <<: *param_cli_cluster_backend
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - <<: *steps_install_go

      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli
      # We don't send metrics to avoid polluting our logs
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: "${KURTOSIS_BINPATH} analytics disable"
      # When backend is 'kubernetes' install kubernetes and start a Kurtosis gateway
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_k8s_k3s

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_docker

      # Basic service add & rm
      - run: |
          ${KURTOSIS_BINPATH} enclave add --name test-enclave
      - run: "${KURTOSIS_BINPATH} service add test-enclave test1 httpd --ports http=80"
      - run: "${KURTOSIS_BINPATH} service rm test-enclave test1"
      - run: "${KURTOSIS_BINPATH} service add test-enclave test1 httpd --ports http=80"
      - run: "${KURTOSIS_BINPATH} service add test-enclave test2 httpd --ports http=80"

      # Service stop and start
      - run: "${KURTOSIS_BINPATH} service stop test-enclave test1"
      - run: "${KURTOSIS_BINPATH} service start test-enclave test1"

      # Service inspect
      - run: "${KURTOSIS_BINPATH} service inspect test-enclave test1"

      # Service Exec
      # Emulates GitHub Actions
      - run: "${KURTOSIS_BINPATH} service exec test-enclave test1 'echo hello'"
      - run: "! ${KURTOSIS_BINPATH} service exec test-enclave test1 'echo hello; exit 1'"

      # File commands
      - run: "${KURTOSIS_BINPATH} files rendertemplate test-enclave << pipeline.parameters.rendertemplate-cli-test-template-relative-path >> << pipeline.parameters.rendertemplate-cli-test-data-json-relative-path >> ./rendered --name rendered-file"
      - run: "${KURTOSIS_BINPATH} files download test-enclave rendered-file ."
      - run: "${KURTOSIS_BINPATH} files storeservice test-enclave test1 /usr/local/apache2/conf/httpd.conf --name stored-file"
      - run: "${KURTOSIS_BINPATH} files download test-enclave stored-file ."

      # Service update
      - run: "${KURTOSIS_BINPATH} service update test-enclave test1 --image httpd:2.4.63 --env 'update=test;where=ci' --ports http=80 --files '/root/somewhere:rendered-file|stored-file'"

      # Check Dump Contains files
      - run: "${KURTOSIS_BINPATH} enclave dump test-enclave test-dump"
      - run: "ls test-dump/files/rendered-file"

      # Module inside an enclave
      - run: "${KURTOSIS_BINPATH} enclave ls"
      - run: "${KURTOSIS_BINPATH} enclave inspect test-enclave"

      # Execute simple startosis script in new enclave
      - run: "${KURTOSIS_BINPATH} run --enclave test-enclave << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.startosis-test-script-file-relative-path >>"

      # Execute Simple Starlark Script to test --args-file
      - run: "${KURTOSIS_BINPATH} run --enclave args-file-test << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.starlark-test-args-file-test-main-star-relative-path >> --args-file << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.starlark-test-args-file-test-args-json-relative-path >>"

      # Execute Simple Starlark Script to test --args-file from URL
      - run: "${KURTOSIS_BINPATH} run --enclave args-file-from-url-test << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.starlark-test-args-file-test-main-star-relative-path >> --args-file << pipeline.parameters.starlark-test-args-file-url >>"

      # Execute github starlark module
      - run: '${KURTOSIS_BINPATH} run --enclave test-datastore github.com/kurtosis-tech/datastore-army-package ''{"num_datastores": 2}'''

      # Execute port print
      - run: "${KURTOSIS_BINPATH} port print test-datastore datastore-0 grpc"

      # Stop test-datastore enclave
      - run: "${KURTOSIS_BINPATH} enclave stop test-datastore"

      # Ensure we can still inspect stopped enclaves
      - run: "${KURTOSIS_BINPATH} enclave stop test-enclave"
      - run: "${KURTOSIS_BINPATH} enclave inspect test-enclave"

      # Clean all before compose import to free resources
      - run: "${KURTOSIS_BINPATH} clean -a"

      # Execute docker compose import
      - run: "${KURTOSIS_BINPATH} import --enclave test-import --env << pipeline.parameters.dockerimport-cli-dotenv-relative-path >> << pipeline.parameters.dockerimport-cli-dockerfile-relative-path >>"

      # This just tests that tolerations don't mess up Docker
      # TODO add proper tests for Docker and Kubernetes that test
      # Adding Toleration to a tainted cluster makes things work
      # Not having toleration fails
      - run: "${KURTOSIS_BINPATH} run --enclave with-tolerations << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.starlark-test-taints-and-tolerations >>"

      # Execute engine functions
      - run: "${KURTOSIS_BINPATH} engine stop"
      - run: "${KURTOSIS_BINPATH} engine stop"
      - run: "${KURTOSIS_BINPATH} engine start"
      - run: "${KURTOSIS_BINPATH} engine start"
      - run: "${KURTOSIS_BINPATH} engine restart"
      - run: "${KURTOSIS_BINPATH} engine restart"
      - run: "${KURTOSIS_BINPATH} engine status"

      # Test APIC restart
      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            - run:
                name: Test APIC restart
                command: |
                  ${KURTOSIS_BINPATH} enclave add -n test-apic-restart
                  ${KURTOSIS_BINPATH} enclave inspect --full-uuids test-apic-restart > /tmp/inspect_output.txt
                  inspect_output_uuid_line=$(grep "^UUID:" /tmp/inspect_output.txt) 
                  enclave_uuid=$(echo ${inspect_output_uuid_line:17:54})
                  ${KURTOSIS_BINPATH} service add test-apic-restart service-test kurtosistech/example-datastore-server
                  apic_container_id=$(docker ps --filter "label=com.kurtosistech.container-type=api-container" --filter "label=com.kurtosistech.enclave-id=$(echo $enclave_uuid)" --format "{{.ID}}")
                  docker container restart $(echo $apic_container_id)
                  ${KURTOSIS_BINPATH} service rm test-apic-restart service-test

      # Test APIC idempotent runs restart
      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            - run:
                name: Test APIC idempotent restart
                command: |
                  ${KURTOSIS_BINPATH} enclave add -n test-apic-idempotent-restart
                  ${KURTOSIS_BINPATH} run github.com/kurtosis-tech/datastore-army-package --enclave test-apic-idempotent-restart
                  ${KURTOSIS_BINPATH} enclave inspect --full-uuids test-apic-idempotent-restart > /tmp/inspect_output2.txt
                  inspect_output_uuid_line=$(grep "^UUID:" /tmp/inspect_output2.txt) 
                  enclave_uuid=$(echo ${inspect_output_uuid_line:17:54})
                  apic_container_id=$(docker ps --filter "label=com.kurtosistech.container-type=api-container" --filter "label=com.kurtosistech.enclave-id=$(echo $enclave_uuid)" --format "{{.ID}}")
                  docker container restart $(echo $apic_container_id)
                  ${KURTOSIS_BINPATH} run github.com/kurtosis-tech/datastore-army-package --enclave test-apic-idempotent-restart > /tmp/output_idempotent_runs.txt
                  number_skipped_instructions=$(grep -o -i SKIPPED /tmp/output_idempotent_runs.txt | wc -l )
                  if [ $number_skipped_instructions -ne 7 ]; then exit 1; fi

      # Clean all at the end
      - run: "${KURTOSIS_BINPATH} clean -a"

      # Ensure Kubernetes resources clean up successfully
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          steps:
            - run:
                name: "Install kubectl"
                # Install kubectl and move it to the /usr/local/bin in order to make it accesible from the PATH
                command: |
                  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                  chmod +x kubectl
                  sudo mv kubectl /usr/local/bin
            - run:
                name: "Verify no kurtosis pods are running after clean and stopping the engine"
                command: |
                  kurtosis_pods=$(kubectl -- get pods --all-namespaces --selector=kurtosistech.com/app-id=kurtosis)
                  if ! [ $(echo "${kurtosis_pods}" |  grep -f <(printf "%s\n" "Running") | wc -l) -eq 0 ]; then
                    echo "${kurtosis_pods}"
                    false
                  fi

      # Ensure Docker resources cleaned up successfully
      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            - run:
                name: "Verify only the engine, logs aggregator and reverse proxy remain after the clean"
                command: |
                  if ! [ "$(docker container ls -a | tail -n+2 | wc -l)" -eq 3 ]; then
                    docker container ls -a
                    false
                  fi
            - run:
                name: "Verify Kurtosis cleaned up all its volumes (except for the log storage, github auth storage, docker auth config, logs aggregator data, logs aggregator config)"
                command: |
                  if ! [ $(docker volume ls | grep -v kurtosis-logs-collector-vol | grep -v kurtosis-logs-db-vol | tail -n+2 | wc -l) -eq 5 ]; then
                    docker volume ls
                    false
                  fi
            - run:
                name: "Verify Kurtosis cleaned up all its networks"
                command: |
                  builtin_network_ids=(
                     "$(docker network ls --quiet --filter "name=host")"
                    "$(docker network ls --quiet --filter "name=bridge")"
                    "$(docker network ls --quiet --filter "name=none")"
                  )
                  if ! [ $(docker network ls | grep -v -f <(printf "%s\n" "${builtin_network_ids[@]}") | tail -n+2 | wc -l) -eq 0 ]; then
                    docker network ls
                    false
                  fi

  test_reverse_proxy:
    executor: ubuntu_vm
    parameters:
      <<: *param_cli_cluster_backend
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - <<: *steps_install_go

      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli curl
      # We don't send metrics to avoid polluting our logs
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: "${KURTOSIS_BINPATH} analytics disable"
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_k8s_k3s

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_docker

      # Start a service and send an http request to it via the reverse proxy
      - run: |
          ${KURTOSIS_BINPATH} enclave add --name test-enclave
          ${KURTOSIS_BINPATH} service add test-enclave test1 httpd --ports http=http:80/tcp
          enclave_uuid=$(${KURTOSIS_BINPATH} enclave inspect test-enclave | grep "^UUID:" | awk '{print $2}')
          service_uuid=$(${KURTOSIS_BINPATH} enclave inspect test-enclave | tail -2 | awk '{print $1}')
          # Give the reverse proxy enough time to discover the httpd user service
          sleep 10
          status_code=$(curl -I http://localhost:<< pipeline.parameters.reverse-proxy-entrypoint-web-port >> -H "Host: 80-$(echo $service_uuid)-$(echo $enclave_uuid)" | head -1 | awk '{print $2}')
          if ! [ "${status_code}" -eq "200" ]; then
            echo 'HTTP request status code returned is '${status_code}' instead of 200'
            false
          fi

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          steps:
            # Restart the engine and make sure Traefik restarted and reconfigured properly
            - run: |
                ${KURTOSIS_BINPATH} engine restart
                enclave_uuid=$(${KURTOSIS_BINPATH} enclave inspect test-enclave | grep "^UUID:" | awk '{print $2}')
                service_uuid=$(${KURTOSIS_BINPATH} enclave inspect test-enclave | tail -2 | awk '{print $1}')
                # Give the reverse proxy enough time to discover the httpd user service
                sleep 10
                status_code=$(curl -I http://localhost:<< pipeline.parameters.reverse-proxy-entrypoint-web-port >> -H "Host: 80-$(echo $service_uuid)-$(echo $enclave_uuid)" | head -1 | awk '{print $2}')
                if ! [ "${status_code}" -eq "200" ]; then
                  echo 'HTTP request status code returned is '${status_code}' instead of 200'
                  false
                fi

  test_ci_for_failure:
    executor: ubuntu_vm
    parameters:
      <<: *param_cli_cluster_backend
    steps:
      - checkout

      - <<: *abort_job_if_only_docs_changes

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - <<: *steps_install_go

      # We don't send metrics to avoid polluting our logs
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: "${KURTOSIS_BINPATH} analytics disable"
      # When backend is 'kubernetes' install kubernetes and start a Kurtosis gateway
      - when:
          condition:
            equal: ["kubernetes", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_k8s_k3s

      - when:
          condition:
            equal: ["docker", << parameters.cli-cluster-backend >>]
          <<: *steps_prepare_testing_docker

      # adding same enclave fails
      - run: "${KURTOSIS_BINPATH} enclave add --name test-enclave"
      - run: "! ${KURTOSIS_BINPATH} service add --name test-encalve"

      # running a broken package fails
      - run: "! ${KURTOSIS_BINPATH} run github.com/kurtosis-tech/datastore-army-package@25ecb4c271f870d6fdf8745169a142519e49aab8"

  # -- End build jobs ---------------------------------------

  # -- Publish jobs --------------------------------------------

  publish_kurtosis_sdk_rust:
    docker:
      - image: "cimg/rust:<< pipeline.parameters.rust-version>>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      - checkout
      - run: |
          cd api/rust/
          cargo publish

  publish_kurtosis_api_typescript:
    docker:
      - image: "cimg/node:<< pipeline.parameters.api-node-version>>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      - checkout
      - run: api/typescript/scripts/build.sh
      - npm-publisher/publish-from-package-version:
          package-path: api/typescript
          publish-token-variable: NPMJS_AUTH_TOKEN

  publish_kurtosis_ui_libs:
    docker:
      - image: "cimg/node:<< pipeline.parameters.ui-node-version>>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      - checkout
      - run: enclave-manager/api/typescript/scripts/build.sh
      - run: enclave-manager/web/scripts/build.sh
      - npm-publisher/publish-from-package-version:
          package-path: enclave-manager/web/packages/components
          publish-token-variable: NPMJS_AUTH_TOKEN

  publish_files_artifacts_expander_image:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      - checkout
      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      - run: |
          skip_docker_image_building=true
          core/files_artifacts_expander/scripts/build.sh "${skip_docker_image_building}"
      - run: |
          skip_docker_image_building=true
          build_architecture=arm64
          core/files_artifacts_expander/scripts/build.sh "${skip_docker_image_building}" "${build_architecture}"
      - run: |
          set -euo pipefail
          source core/files_artifacts_expander/scripts/_constants.env
          dockerfile_filepath='core/files_artifacts_expander/Dockerfile'
          version_build="$(./scripts/get-docker-tag.sh)"
          version_to_publish="$(cat version.txt)"
          echo "Version that was built: ${version_build}"
          echo "Version that will be published: ${version_to_publish}"
          image_name_with_version="${IMAGE_ORG_AND_REPO}:${version_build}"
          image_name_to_publish_semver="${IMAGE_ORG_AND_REPO}:${version_to_publish}"
          image_name_to_publish_latest="${IMAGE_ORG_AND_REPO}:latest"
          push_to_dockerhub=true
          podman_mode=false
          scripts/docker-image-builder.sh "${push_to_dockerhub}" "${dockerfile_filepath}" "${podman_mode}" "${image_name_with_version}" "${image_name_to_publish_semver}" "${image_name_to_publish_latest}"

  publish_api_container_server_image:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      # Install proto compiler. To compile startosis proto files on the fly, the APIC needs `protoc`
      - run: |
          sudo apt update
          sudo apt install protobuf-compiler

      - checkout

      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      - run: |
          skip_docker_image_building=true
          core/server/scripts/build.sh "${skip_docker_image_building}"
      - run: |
          skip_docker_image_building=true
          build_architecture=arm64
          core/server/scripts/build.sh "${skip_docker_image_building}" "${build_architecture}"
      - run: |
          set -euo pipefail
          source core/server/scripts/_constants.env
          dockerfile_filepath='core/server/Dockerfile'
          version_build="$(./scripts/get-docker-tag.sh)"
          version_to_publish="$(cat version.txt)"
          echo "Version that was built: ${version_build}"
          echo "Version that will be published: ${version_to_publish}"
          image_name_with_version="${IMAGE_ORG_AND_REPO}:${version_build}"
          image_name_to_publish_semver="${IMAGE_ORG_AND_REPO}:${version_to_publish}"
          image_name_to_publish_latest="${IMAGE_ORG_AND_REPO}:latest"
          push_to_dockerhub=true
          podman_mode=false
          scripts/docker-image-builder.sh "${push_to_dockerhub}" "${dockerfile_filepath}" "${podman_mode}" "${image_name_with_version}" "${image_name_to_publish_semver}" "${image_name_to_publish_latest}"

  publish_engine_server_image:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version >>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      - checkout

      # Generate Kurtosis Version
      - run: |
          version="$(cat version.txt)"
          "<<pipeline.parameters.generate-kurtosis-version-script-path>>" $version

      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>"

      - run: cp -R << pipeline.parameters.workspace-with-cli-binary-and-images-mountpoint >>/webapp engine/server/webapp

      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      - run: |
          skip_docker_image_building=true
          engine/server/scripts/build.sh "${skip_docker_image_building}"
      - run: |
          skip_docker_image_building=true
          build_architecture=arm64          
          engine/server/scripts/build.sh "${skip_docker_image_building}" "${build_architecture}"
      - run: |
          set -euo pipefail
          source engine/server/scripts/_constants.env
          dockerfile_filepath='engine/server/Dockerfile'
          version_build="$(./scripts/get-docker-tag.sh)"
          version_to_publish="$(cat version.txt)"
          echo "Version that was built: ${version_build}"
          echo "Version that will be published: ${version_to_publish}"
          image_name_with_version="${IMAGE_ORG_AND_REPO}:${version_build}"
          image_name_to_publish_semver="${IMAGE_ORG_AND_REPO}:${version_to_publish}"
          image_name_to_publish_latest="${IMAGE_ORG_AND_REPO}:latest"
          push_to_dockerhub=true
          podman_mode=false
          scripts/docker-image-builder.sh "${push_to_dockerhub}" "${dockerfile_filepath}" "${podman_mode}" "${image_name_with_version}" "${image_name_to_publish_semver}" "${image_name_to_publish_latest}"

  push_cli_artifacts:
    # we use this docker/tilt-releaser image for cli jobs because starlark-lsp requires it to build
    # as opposed to running image off cimg/go:<< pipeline.parameters.go-version like every other job
    # The starlark-lsp uses treesitter which has direct c bindings; and making a go releaser cross arch build
    # requires a lot of tooling; when the original author adding starlark-lsp to the project they copied the tilt-releaser
    # which came with all of the underlying tooling instead of bundling their own image; perhaps due to time constraints
    docker:
      - image: "docker/tilt-releaser@sha256:<< pipeline.parameters.tilt-releaser-version >>"
    steps:
      - slack/notify:
          channel: engineering
          event: fail
          # You can preview this template and know more about templates here: https://github.com/CircleCI-Public/slack-orb/wiki#templates
          template: basic_fail_1

      # Install goreleaser
      - run: |
          echo 'deb [trusted=yes] https://repo.goreleaser.com/apt/ /' | tee /etc/apt/sources.list.d/goreleaser.list
          curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -
          apt update
          apt install -y goreleaser
      - checkout
      # Generate Kurtosis Version
      - run: |
          version="$(cat version.txt)"
          "<<pipeline.parameters.generate-kurtosis-version-script-path>>" $version

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.cli-build-cache-key-prefix >>-{{ checksum "cli/cli/go.sum" }}

      - run: |
          cli/cli/scripts/build.sh true true

      - save_cache:
          key: << pipeline.parameters.cli-build-cache-key-prefix >>-{{ checksum "cli/cli/go.sum" }}
          paths:
            - "/go/pkg/mod" # Go module cache for the Goreleaser image, as reported by "go env GOMODCACHE"
            - "/root/.cache/go-build" # Go build cache for the Goreleaser image, as reported by "go env GOCACHE"

  # -- End publishing jobs -------------------------------------

workflows:
  build:
    jobs:
      # -- build jobs ------------------------------------------
      - kurtosis-docs-checker/check-docs:
          dir-to-exclude: "^(./docs/*|./CHANGELOG.md)"
          should-check-changelog: false
          markdown-link-check-config-json: |
            {
                "replacementPatterns": [
                    {
                        "pattern": "^../kurtosis/",
                        "replacement": "https://kurtosis-tech.github.io/kurtosis/"
                    }
                ],
                "ignorePatterns": [
                    {
                        "pattern": "https://github.com/kurtosis-tech/kurtosis-internal-docs/.*"
                    },
                    {
                        "pattern": "https://www.notion.so/kurtosistech.*"
                    },
                    {
                        "pattern": "https://github.com/kurtosis-tech/kurtosis/compare/.*"
                    },
                    {
                        "pattern": "https://twitter.com/.*"
                    },
                    {
                        "pattern": "http://localhost:.*"
                    },
                    {
                        "pattern": "http://localhost/.*"
                    },
                    {
                       "pattern": "https://react-hook-form.com/.*"
                    }
                ]
            }
          filters:
            branches:
              ignore:
                - main
                - release-please--branches--main--components--kurtosis
                - gh-readonly-queue/main/.*

      - build_container_engine_lib:
          filters:
            branches:
              ignore:
                - main

      - build_contexts_config_store:
          filters:
            branches:
              ignore:
                - main

      - build_grpc_file_transfer:
          filters:
            branches:
              ignore:
                - main

      - build_metrics_library:
          filters:
            branches:
              ignore:
                - main

      - build_name_generator:
          filters:
            branches:
              ignore:
                - main

      - build_kurtosis_api_golang:
          # NOTE: Do NOT add our private Github user here; the API must be publicly-accessible so must build without them
          context: []
          filters:
            branches:
              ignore:
                - main
      - build_kurtosis_api_typescript:
          filters:
            branches:
              ignore:
                - main
      - build_files_artifacts_expander:
          context:
            - docker-user
          filters:
            branches:
              ignore:
                - main
      - build_core_launcher:
          filters:
            branches:
              ignore:
                - main
      - build_api_container_server:
          context:
            - docker-user
          filters:
            branches:
              ignore:
                - main

      - build_enclave_manager_webapp:
          <<: *filters_ignore_main

      - build_engine_launcher:
          filters:
            branches:
              ignore:
                - main
      - build_engine_server:
          context:
            - docker-user
          requires:
            - build_enclave_manager_webapp
          filters:
            branches:
              ignore:
                - main

      - build_cli:
          <<: *filters_ignore_main

      - build_cli:
          all_architectures: true
          name: "Check if CLI builds for all os and arch pairs"
          <<: *filters_ignore_main

      - test_basic_cli_functionality:
          name: "Test Basic CLI Functionality in Docker"
          cli-cluster-backend: "docker"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      #      - test_basic_cli_functionality:
      #          name: "Test Basic CLI Functionality in Kubernetes"
      #          cli-cluster-backend: "kubernetes"
      #          context:
      #            - docker-user
      #          requires:
      #            - build_cli
      #            - build_api_container_server
      #            - build_engine_server
      #            - build_files_artifacts_expander
      #          <<: *filters_ignore_main

      - test_ci_for_failure:
          name: "Test Basic CLI for failure"
          cli-cluster-backend: "docker"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - build_golang_testsuite:
          name: "Build golang testsuite against Docker"
          cli-cluster-backend: "docker"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - build_golang_testsuite:
          name: "Build golang testsuite against Kubernetes"
          cli-cluster-backend: "kubernetes"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - build_typescript_testsuite:
          name: "Build typescript testsuite against Docker"
          cli-cluster-backend: "docker"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - build_typescript_testsuite:
          name: "Build typescript testsuite against Kubernetes"
          cli-cluster-backend: "kubernetes"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - test_old_enclave_continuity:
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - test_reverse_proxy:
          name: "Test reverse proxy against Docker"
          cli-cluster-backend: "docker"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

      - test_reverse_proxy:
          name: "Test reverse proxy against Kubernetes"
          cli-cluster-backend: "kubernetes"
          context:
            - docker-user
          requires:
            - build_cli
            - build_api_container_server
            - build_engine_server
            - build_files_artifacts_expander
          <<: *filters_ignore_main

  publish:
    jobs:
      # -- Artifact-publishing jobs --------------------------------
      - publish_kurtosis_sdk_rust:
          context:
            - crates-publisher
            - slack-secrets
          <<: *filters_ignore_tags

      - publish_kurtosis_api_typescript:
          context:
            - npmjs-user
            - slack-secrets
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^[0-9]+\.[0-9]+\.[0-9]+$/
      - publish_kurtosis_ui_libs:
          context:
            - npmjs-user
            - slack-secrets
          <<: *filters_ignore_tags
      - publish_files_artifacts_expander_image:
          context:
            - docker-user
            - slack-secrets
          <<: *filters_ignore_tags
      - publish_api_container_server_image:
          context:
            - docker-user
            - slack-secrets
          <<: *filters_ignore_tags

      - build_enclave_manager_webapp:
          <<: *filters_ignore_tags

      - publish_engine_server_image:
          context:
            - docker-user
            - slack-secrets
          requires:
            - build_enclave_manager_webapp
          <<: *filters_ignore_tags

      - push_cli_artifacts:
          context:
            - gemfury-publisher
            - github-user
            - slack-secrets
          requires:
            - publish_kurtosis_api_typescript
            - publish_kurtosis_sdk_rust
            - publish_api_container_server_image
            - publish_engine_server_image
            - publish_files_artifacts_expander_image
          <<: *filters_ignore_tags

      # -- End artifact-publishing jobs ----------------------------
