// Code generated by Fern. DO NOT EDIT.

package enclave

import (
	context "context"
	io "io"

	sdk "github.com/kurtosis-tech/kurtosis/sdks/go"
	core "github.com/kurtosis-tech/kurtosis/sdks/go/core"
	internal "github.com/kurtosis-tech/kurtosis/sdks/go/internal"
	option "github.com/kurtosis-tech/kurtosis/sdks/go/option"
)

type Client struct {
	WithRawResponse *RawClient

	options *core.RequestOptions
	baseURL string
	caller  *internal.Caller
}

func NewClient(options *core.RequestOptions) *Client {
	return &Client{
		WithRawResponse: NewRawClient(options),
		options:         options,
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
	}
}

func (c *Client) GetLastStarlarkRun(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	opts ...option.RequestOption,
) (*sdk.StarlarkDescription, error) {
	response, err := c.WithRawResponse.GetLastStarlarkRun(
		ctx,
		enclaveIdentifier,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Uploads a Starlark package. This step is required before the package can be executed with RunStarlarkPackage
func (c *Client) UploadsAStarlarkPackage(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// request *sdk.PostEnclavesEnclaveIdentifierStarlarkPackagesRequest,
	opts ...option.RequestOption,
) error {
	_, err := c.WithRawResponse.UploadsAStarlarkPackage(
		ctx,
		enclaveIdentifier,
		// request,
		opts...,
	)
	if err != nil {
		return err
	}
	return nil
}

// The endpoint will trigger the execution and deployment of a Starlark package. By default, it'll
// return an async logs resource using `starlark_execution_uuid` that can be used to retrieve the logs
// via streaming. It's also possible to block the call and wait for the execution to complete using the
// query parameter `retrieve_logs_async`.
func (c *Client) ExecutesAStarlarkPackageOnTheUsersBehalf(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The package identifier that will be executed
	packageId string,
	request *sdk.RunStarlarkPackage,
	opts ...option.RequestOption,
) (*sdk.StarlarkRunResponse, error) {
	response, err := c.WithRawResponse.ExecutesAStarlarkPackageOnTheUsersBehalf(
		ctx,
		enclaveIdentifier,
		packageId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// The endpoint will trigger the execution and deployment of a Starlark file. By default, it'll
// return an async logs resource using `starlark_execution_uuid` that can be used to retrieve the logs
// via streaming. It's also possible to block the call and wait for the execution to complete using the
// query parameter `retrieve_logs_async`.
func (c *Client) ExecutesAStarlarkScriptOnTheUsersBehalf(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	request *sdk.RunStarlarkScript,
	opts ...option.RequestOption,
) (*sdk.StarlarkRunResponse, error) {
	response, err := c.WithRawResponse.ExecutesAStarlarkScriptOnTheUsersBehalf(
		ctx,
		enclaveIdentifier,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ReturnsDetailedInformationAboutASpecificService(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The service identifier of the container that the command should be executed in
	serviceIdentifier string,
	opts ...option.RequestOption,
) (*sdk.ServiceInfo, error) {
	response, err := c.WithRawResponse.ReturnsDetailedInformationAboutASpecificService(
		ctx,
		enclaveIdentifier,
		serviceIdentifier,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ReturnsInformationAboutAllExistingHistoricalServices(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	opts ...option.RequestOption,
) ([]*sdk.ServiceIdentifiers, error) {
	response, err := c.WithRawResponse.ReturnsInformationAboutAllExistingHistoricalServices(
		ctx,
		enclaveIdentifier,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ReturnsDetailedInformationAboutAllsServicesWithinTheEnclave(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	request *sdk.GetEnclavesEnclaveIdentifierServicesRequest,
	opts ...option.RequestOption,
) (map[string]*sdk.ServiceInfo, error) {
	response, err := c.WithRawResponse.ReturnsDetailedInformationAboutAllsServicesWithinTheEnclave(
		ctx,
		enclaveIdentifier,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ExecutesTheGivenCommandInsideARunningServicesContainer(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The service identifier of the container that the command should be executed in
	serviceIdentifier string,
	request *sdk.ExecCommand,
	opts ...option.RequestOption,
) (*sdk.ExecCommandResult, error) {
	response, err := c.WithRawResponse.ExecutesTheGivenCommandInsideARunningServicesContainer(
		ctx,
		enclaveIdentifier,
		serviceIdentifier,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Block until the given HTTP endpoint returns available, calling it through a HTTP request
func (c *Client) CheckForServiceAvailability(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The service identifier of the container that the command should be executed in
	serviceIdentifier string,
	// The port number to check availability
	portNumber int,
	request *sdk.GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest,
	opts ...option.RequestOption,
) error {
	_, err := c.WithRawResponse.CheckForServiceAvailability(
		ctx,
		enclaveIdentifier,
		serviceIdentifier,
		portNumber,
		request,
		opts...,
	)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) ListAllFilesArtifacts(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	opts ...option.RequestOption,
) ([]*sdk.FileArtifactReference, error) {
	response, err := c.WithRawResponse.ListAllFilesArtifacts(
		ctx,
		enclaveIdentifier,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) InspectTheContentOfAFileArtifact(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The artifact name or uuid
	artifactIdentifier string,
	opts ...option.RequestOption,
) ([]*sdk.FileArtifactDescription, error) {
	response, err := c.WithRawResponse.InspectTheContentOfAFileArtifact(
		ctx,
		enclaveIdentifier,
		artifactIdentifier,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) DownloadsAFilesArtifactFromTheKurtosisFileSystem(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The artifact name or uuid
	artifactIdentifier string,
	opts ...option.RequestOption,
) (io.Reader, error) {
	response, err := c.WithRawResponse.DownloadsAFilesArtifactFromTheKurtosisFileSystem(
		ctx,
		enclaveIdentifier,
		artifactIdentifier,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) UploadsLocalFileArtifactToTheKurtosisFileSystem(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// request *sdk.PostEnclavesEnclaveIdentifierArtifactsLocalFileRequest,
	opts ...option.RequestOption,
) (map[string]*sdk.FileArtifactUploadResult, error) {
	response, err := c.WithRawResponse.UploadsLocalFileArtifactToTheKurtosisFileSystem(
		ctx,
		enclaveIdentifier,
		// request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Tells the API container to download a files artifact from the web to the Kurtosis File System
func (c *Client) AddRemoteFileToKurtosisFileSystem(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	request *sdk.StoreWebFilesArtifact,
	opts ...option.RequestOption,
) (*sdk.FileArtifactReference, error) {
	response, err := c.WithRawResponse.AddRemoteFileToKurtosisFileSystem(
		ctx,
		enclaveIdentifier,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Tells the API container to copy a files artifact from a service to the Kurtosis File System
func (c *Client) AddServicesFileToKurtosisFileSystem(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	// The service identifier of the container that the command should be executed in
	serviceIdentifier string,
	request *sdk.StoreFilesArtifactFromService,
	opts ...option.RequestOption,
) (*sdk.FileArtifactReference, error) {
	response, err := c.WithRawResponse.AddServicesFileToKurtosisFileSystem(
		ctx,
		enclaveIdentifier,
		serviceIdentifier,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) UserServicesPortForwarding(
	ctx context.Context,
	// UUID, shortened UUID, or name of the enclave
	enclaveIdentifier string,
	request *sdk.Connect,
	opts ...option.RequestOption,
) error {
	_, err := c.WithRawResponse.UserServicesPortForwarding(
		ctx,
		enclaveIdentifier,
		request,
		opts...,
	)
	if err != nil {
		return err
	}
	return nil
}
