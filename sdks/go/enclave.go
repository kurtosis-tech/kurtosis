// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
)

var (
	storeWebFilesArtifactFieldUrl  = big.NewInt(1 << 0)
	storeWebFilesArtifactFieldName = big.NewInt(1 << 1)
)

type StoreWebFilesArtifact struct {
	// URL to download the artifact from
	Url string `json:"url" url:"-"`
	// The name of the files artifact
	Name string `json:"name" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StoreWebFilesArtifact) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StoreWebFilesArtifact) SetUrl(url string) {
	s.Url = url
	s.require(storeWebFilesArtifactFieldUrl)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StoreWebFilesArtifact) SetName(name string) {
	s.Name = name
	s.require(storeWebFilesArtifactFieldName)
}

var (
	storeFilesArtifactFromServiceFieldSourcePath = big.NewInt(1 << 0)
	storeFilesArtifactFromServiceFieldName       = big.NewInt(1 << 1)
)

type StoreFilesArtifactFromService struct {
	// The absolute source path where the source files will be copied from
	SourcePath string `json:"source_path" url:"-"`
	// The name of the files artifact
	Name string `json:"name" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StoreFilesArtifactFromService) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSourcePath sets the SourcePath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StoreFilesArtifactFromService) SetSourcePath(sourcePath string) {
	s.SourcePath = sourcePath
	s.require(storeFilesArtifactFromServiceFieldSourcePath)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StoreFilesArtifactFromService) SetName(name string) {
	s.Name = name
	s.require(storeFilesArtifactFromServiceFieldName)
}

var (
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldHttpMethod               = big.NewInt(1 << 0)
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldPath                     = big.NewInt(1 << 1)
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldInitialDelayMilliseconds = big.NewInt(1 << 2)
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldRetries                  = big.NewInt(1 << 3)
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldRetriesDelayMilliseconds = big.NewInt(1 << 4)
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldExpectedResponse         = big.NewInt(1 << 5)
	getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldRequestBody              = big.NewInt(1 << 6)
)

type GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest struct {
	// The HTTP method used to check availability. Default is GET.
	HttpMethod *HttpMethodAvailability `json:"-" url:"http_method,omitempty"`
	// The path of the service to check. It mustn't start with the first slash. For instance `service/health`
	Path *string `json:"-" url:"path,omitempty"`
	// The number of milliseconds to wait until executing the first HTTP call
	InitialDelayMilliseconds *int `json:"-" url:"initial_delay_milliseconds,omitempty"`
	// Max number of HTTP call attempts that this will execute until giving up and returning an error
	Retries *int `json:"-" url:"retries,omitempty"`
	// Number of milliseconds to wait between retries
	RetriesDelayMilliseconds *int `json:"-" url:"retries_delay_milliseconds,omitempty"`
	// If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
	ExpectedResponse *string `json:"-" url:"expected_response,omitempty"`
	// If the http_method is set to POST, this value will be send as the body of the availability request.
	RequestBody *string `json:"-" url:"request_body,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetHttpMethod sets the HttpMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetHttpMethod(httpMethod *HttpMethodAvailability) {
	g.HttpMethod = httpMethod
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldHttpMethod)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetPath(path *string) {
	g.Path = path
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldPath)
}

// SetInitialDelayMilliseconds sets the InitialDelayMilliseconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetInitialDelayMilliseconds(initialDelayMilliseconds *int) {
	g.InitialDelayMilliseconds = initialDelayMilliseconds
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldInitialDelayMilliseconds)
}

// SetRetries sets the Retries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetRetries(retries *int) {
	g.Retries = retries
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldRetries)
}

// SetRetriesDelayMilliseconds sets the RetriesDelayMilliseconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetRetriesDelayMilliseconds(retriesDelayMilliseconds *int) {
	g.RetriesDelayMilliseconds = retriesDelayMilliseconds
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldRetriesDelayMilliseconds)
}

// SetExpectedResponse sets the ExpectedResponse field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetExpectedResponse(expectedResponse *string) {
	g.ExpectedResponse = expectedResponse
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldExpectedResponse)
}

// SetRequestBody sets the RequestBody field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequest) SetRequestBody(requestBody *string) {
	g.RequestBody = requestBody
	g.require(getEnclavesEnclaveIdentifierServicesServiceIdentifierEndpointsPortNumberAvailabilityRequestFieldRequestBody)
}

var (
	runStarlarkPackageFieldRetrieveLogsAsync      = big.NewInt(1 << 0)
	runStarlarkPackageFieldParams                 = big.NewInt(1 << 1)
	runStarlarkPackageFieldDryRun                 = big.NewInt(1 << 2)
	runStarlarkPackageFieldParallelism            = big.NewInt(1 << 3)
	runStarlarkPackageFieldClonePackage           = big.NewInt(1 << 4)
	runStarlarkPackageFieldRelativePathToMainFile = big.NewInt(1 << 5)
	runStarlarkPackageFieldMainFunctionName       = big.NewInt(1 << 6)
	runStarlarkPackageFieldExperimentalFeatures   = big.NewInt(1 << 7)
	runStarlarkPackageFieldCloudInstanceId        = big.NewInt(1 << 8)
	runStarlarkPackageFieldCloudUserId            = big.NewInt(1 << 9)
	runStarlarkPackageFieldImageDownloadMode      = big.NewInt(1 << 10)
	runStarlarkPackageFieldNonBlockingMode        = big.NewInt(1 << 11)
	runStarlarkPackageFieldGithubAuthToken        = big.NewInt(1 << 12)
)

type RunStarlarkPackage struct {
	// If false, block http response until all logs are available. Default is true
	RetrieveLogsAsync *bool `json:"-" url:"retrieve_logs_async,omitempty"`
	// Parameters data for the Starlark package main function
	Params map[string]interface{} `json:"params,omitempty" url:"-"`
	// Defaults to false
	DryRun *bool `json:"dry_run,omitempty" url:"-"`
	// Defaults to 4
	Parallelism *int `json:"parallelism,omitempty" url:"-"`
	// Whether the package should be cloned or not.
	// If false, then the package will be pulled from the APIC local package store. If it's a local package then is must
	// have been uploaded using UploadStarlarkPackage prior to calling RunStarlarkPackage.
	// If true, then the package will be cloned from GitHub before execution starts
	ClonePackage *bool `json:"clone_package,omitempty" url:"-"`
	// The relative main file filepath, the default value is the "main.star" file in the root of a package
	RelativePathToMainFile *string `json:"relative_path_to_main_file,omitempty" url:"-"`
	// The name of the main function, the default value is "run"
	MainFunctionName     *string               `json:"main_function_name,omitempty" url:"-"`
	ExperimentalFeatures []KurtosisFeatureFlag `json:"experimental_features,omitempty" url:"-"`
	// Defaults to empty
	CloudInstanceId *string `json:"cloud_instance_id,omitempty" url:"-"`
	// Defaults to empty
	CloudUserId       *string            `json:"cloud_user_id,omitempty" url:"-"`
	ImageDownloadMode *ImageDownloadMode `json:"image_download_mode,omitempty" url:"-"`
	// Defaults to false
	NonBlockingMode *bool `json:"non_blocking_mode,omitempty" url:"-"`
	// Defaults to empty
	GithubAuthToken *string `json:"github_auth_token,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RunStarlarkPackage) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRetrieveLogsAsync sets the RetrieveLogsAsync field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetRetrieveLogsAsync(retrieveLogsAsync *bool) {
	r.RetrieveLogsAsync = retrieveLogsAsync
	r.require(runStarlarkPackageFieldRetrieveLogsAsync)
}

// SetParams sets the Params field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetParams(params map[string]interface{}) {
	r.Params = params
	r.require(runStarlarkPackageFieldParams)
}

// SetDryRun sets the DryRun field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetDryRun(dryRun *bool) {
	r.DryRun = dryRun
	r.require(runStarlarkPackageFieldDryRun)
}

// SetParallelism sets the Parallelism field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetParallelism(parallelism *int) {
	r.Parallelism = parallelism
	r.require(runStarlarkPackageFieldParallelism)
}

// SetClonePackage sets the ClonePackage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetClonePackage(clonePackage *bool) {
	r.ClonePackage = clonePackage
	r.require(runStarlarkPackageFieldClonePackage)
}

// SetRelativePathToMainFile sets the RelativePathToMainFile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetRelativePathToMainFile(relativePathToMainFile *string) {
	r.RelativePathToMainFile = relativePathToMainFile
	r.require(runStarlarkPackageFieldRelativePathToMainFile)
}

// SetMainFunctionName sets the MainFunctionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetMainFunctionName(mainFunctionName *string) {
	r.MainFunctionName = mainFunctionName
	r.require(runStarlarkPackageFieldMainFunctionName)
}

// SetExperimentalFeatures sets the ExperimentalFeatures field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetExperimentalFeatures(experimentalFeatures []KurtosisFeatureFlag) {
	r.ExperimentalFeatures = experimentalFeatures
	r.require(runStarlarkPackageFieldExperimentalFeatures)
}

// SetCloudInstanceId sets the CloudInstanceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetCloudInstanceId(cloudInstanceId *string) {
	r.CloudInstanceId = cloudInstanceId
	r.require(runStarlarkPackageFieldCloudInstanceId)
}

// SetCloudUserId sets the CloudUserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetCloudUserId(cloudUserId *string) {
	r.CloudUserId = cloudUserId
	r.require(runStarlarkPackageFieldCloudUserId)
}

// SetImageDownloadMode sets the ImageDownloadMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetImageDownloadMode(imageDownloadMode *ImageDownloadMode) {
	r.ImageDownloadMode = imageDownloadMode
	r.require(runStarlarkPackageFieldImageDownloadMode)
}

// SetNonBlockingMode sets the NonBlockingMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetNonBlockingMode(nonBlockingMode *bool) {
	r.NonBlockingMode = nonBlockingMode
	r.require(runStarlarkPackageFieldNonBlockingMode)
}

// SetGithubAuthToken sets the GithubAuthToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkPackage) SetGithubAuthToken(githubAuthToken *string) {
	r.GithubAuthToken = githubAuthToken
	r.require(runStarlarkPackageFieldGithubAuthToken)
}

var (
	runStarlarkScriptFieldRetrieveLogsAsync    = big.NewInt(1 << 0)
	runStarlarkScriptFieldSerializedScript     = big.NewInt(1 << 1)
	runStarlarkScriptFieldParams               = big.NewInt(1 << 2)
	runStarlarkScriptFieldDryRun               = big.NewInt(1 << 3)
	runStarlarkScriptFieldParallelism          = big.NewInt(1 << 4)
	runStarlarkScriptFieldMainFunctionName     = big.NewInt(1 << 5)
	runStarlarkScriptFieldExperimentalFeatures = big.NewInt(1 << 6)
	runStarlarkScriptFieldCloudInstanceId      = big.NewInt(1 << 7)
	runStarlarkScriptFieldCloudUserId          = big.NewInt(1 << 8)
	runStarlarkScriptFieldImageDownloadMode    = big.NewInt(1 << 9)
	runStarlarkScriptFieldNonBlockingMode      = big.NewInt(1 << 10)
)

type RunStarlarkScript struct {
	// If false, block http response until all logs are available. Default is true
	RetrieveLogsAsync *bool  `json:"-" url:"retrieve_logs_async,omitempty"`
	SerializedScript  string `json:"serialized_script" url:"-"`
	// Parameters data for the Starlark package main function
	Params map[string]interface{} `json:"params,omitempty" url:"-"`
	// Defaults to false
	DryRun *bool `json:"dry_run,omitempty" url:"-"`
	// Defaults to 4
	Parallelism *int `json:"parallelism,omitempty" url:"-"`
	// The name of the main function, the default value is "run"
	MainFunctionName     *string               `json:"main_function_name,omitempty" url:"-"`
	ExperimentalFeatures []KurtosisFeatureFlag `json:"experimental_features,omitempty" url:"-"`
	// Defaults to empty
	CloudInstanceId *string `json:"cloud_instance_id,omitempty" url:"-"`
	// Defaults to empty
	CloudUserId       *string            `json:"cloud_user_id,omitempty" url:"-"`
	ImageDownloadMode *ImageDownloadMode `json:"image_download_mode,omitempty" url:"-"`
	// Defaults to false
	NonBlockingMode *bool `json:"non_blocking_mode,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RunStarlarkScript) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRetrieveLogsAsync sets the RetrieveLogsAsync field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetRetrieveLogsAsync(retrieveLogsAsync *bool) {
	r.RetrieveLogsAsync = retrieveLogsAsync
	r.require(runStarlarkScriptFieldRetrieveLogsAsync)
}

// SetSerializedScript sets the SerializedScript field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetSerializedScript(serializedScript string) {
	r.SerializedScript = serializedScript
	r.require(runStarlarkScriptFieldSerializedScript)
}

// SetParams sets the Params field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetParams(params map[string]interface{}) {
	r.Params = params
	r.require(runStarlarkScriptFieldParams)
}

// SetDryRun sets the DryRun field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetDryRun(dryRun *bool) {
	r.DryRun = dryRun
	r.require(runStarlarkScriptFieldDryRun)
}

// SetParallelism sets the Parallelism field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetParallelism(parallelism *int) {
	r.Parallelism = parallelism
	r.require(runStarlarkScriptFieldParallelism)
}

// SetMainFunctionName sets the MainFunctionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetMainFunctionName(mainFunctionName *string) {
	r.MainFunctionName = mainFunctionName
	r.require(runStarlarkScriptFieldMainFunctionName)
}

// SetExperimentalFeatures sets the ExperimentalFeatures field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetExperimentalFeatures(experimentalFeatures []KurtosisFeatureFlag) {
	r.ExperimentalFeatures = experimentalFeatures
	r.require(runStarlarkScriptFieldExperimentalFeatures)
}

// SetCloudInstanceId sets the CloudInstanceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetCloudInstanceId(cloudInstanceId *string) {
	r.CloudInstanceId = cloudInstanceId
	r.require(runStarlarkScriptFieldCloudInstanceId)
}

// SetCloudUserId sets the CloudUserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetCloudUserId(cloudUserId *string) {
	r.CloudUserId = cloudUserId
	r.require(runStarlarkScriptFieldCloudUserId)
}

// SetImageDownloadMode sets the ImageDownloadMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetImageDownloadMode(imageDownloadMode *ImageDownloadMode) {
	r.ImageDownloadMode = imageDownloadMode
	r.require(runStarlarkScriptFieldImageDownloadMode)
}

// SetNonBlockingMode sets the NonBlockingMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RunStarlarkScript) SetNonBlockingMode(nonBlockingMode *bool) {
	r.NonBlockingMode = nonBlockingMode
	r.require(runStarlarkScriptFieldNonBlockingMode)
}

var (
	execCommandFieldCommandArgs = big.NewInt(1 << 0)
)

type ExecCommand struct {
	CommandArgs []string `json:"command_args,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *ExecCommand) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetCommandArgs sets the CommandArgs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExecCommand) SetCommandArgs(commandArgs []string) {
	e.CommandArgs = commandArgs
	e.require(execCommandFieldCommandArgs)
}

var (
	getEnclavesEnclaveIdentifierServicesRequestFieldServices = big.NewInt(1 << 0)
)

type GetEnclavesEnclaveIdentifierServicesRequest struct {
	// Select services to get information
	Services []*string `json:"-" url:"services,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetEnclavesEnclaveIdentifierServicesRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetServices sets the Services field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetEnclavesEnclaveIdentifierServicesRequest) SetServices(services []*string) {
	g.Services = services
	g.require(getEnclavesEnclaveIdentifierServicesRequestFieldServices)
}

// Use it to asynchronously retrieve the execution logs via Websockets or http streaming
var (
	asyncStarlarkExecutionLogsFieldAsyncStarlarkExecutionLogs = big.NewInt(1 << 0)
)

type AsyncStarlarkExecutionLogs struct {
	// Execution UUID to asynchronously retrieve the execution logs
	AsyncStarlarkExecutionLogs *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs `json:"async_starlark_execution_logs" url:"async_starlark_execution_logs"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AsyncStarlarkExecutionLogs) GetAsyncStarlarkExecutionLogs() *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs {
	if a == nil {
		return nil
	}
	return a.AsyncStarlarkExecutionLogs
}

func (a *AsyncStarlarkExecutionLogs) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AsyncStarlarkExecutionLogs) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAsyncStarlarkExecutionLogs sets the AsyncStarlarkExecutionLogs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AsyncStarlarkExecutionLogs) SetAsyncStarlarkExecutionLogs(asyncStarlarkExecutionLogs *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) {
	a.AsyncStarlarkExecutionLogs = asyncStarlarkExecutionLogs
	a.require(asyncStarlarkExecutionLogsFieldAsyncStarlarkExecutionLogs)
}

func (a *AsyncStarlarkExecutionLogs) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncStarlarkExecutionLogs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncStarlarkExecutionLogs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncStarlarkExecutionLogs) MarshalJSON() ([]byte, error) {
	type embed AsyncStarlarkExecutionLogs
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AsyncStarlarkExecutionLogs) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Execution UUID to asynchronously retrieve the execution logs
var (
	asyncStarlarkExecutionLogsAsyncStarlarkExecutionLogsFieldStarlarkExecutionUuid = big.NewInt(1 << 0)
)

type AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs struct {
	StarlarkExecutionUuid string `json:"starlark_execution_uuid" url:"starlark_execution_uuid"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) GetStarlarkExecutionUuid() string {
	if a == nil {
		return ""
	}
	return a.StarlarkExecutionUuid
}

func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetStarlarkExecutionUuid sets the StarlarkExecutionUuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) SetStarlarkExecutionUuid(starlarkExecutionUuid string) {
	a.StarlarkExecutionUuid = starlarkExecutionUuid
	a.require(asyncStarlarkExecutionLogsAsyncStarlarkExecutionLogsFieldStarlarkExecutionUuid)
}

func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) MarshalJSON() ([]byte, error) {
	type embed AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AsyncStarlarkExecutionLogsAsyncStarlarkExecutionLogs) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// 0 - CONNECT // Best effort port forwarding
// 1 - NO_CONNECT // Port forwarding disabled
type Connect string

const (
	ConnectConnect   Connect = "CONNECT"
	ConnectNoConnect Connect = "NO_CONNECT"
)

func NewConnectFromString(s string) (Connect, error) {
	switch s {
	case "CONNECT":
		return ConnectConnect, nil
	case "NO_CONNECT":
		return ConnectNoConnect, nil
	}
	var t Connect
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Connect) Ptr() *Connect {
	return &c
}

var (
	containerFieldStatus         = big.NewInt(1 << 0)
	containerFieldImageName      = big.NewInt(1 << 1)
	containerFieldEntrypointArgs = big.NewInt(1 << 2)
	containerFieldCmdArgs        = big.NewInt(1 << 3)
	containerFieldEnvVars        = big.NewInt(1 << 4)
)

type Container struct {
	Status         ContainerStatus   `json:"status" url:"status"`
	ImageName      string            `json:"image_name" url:"image_name"`
	EntrypointArgs []string          `json:"entrypoint_args" url:"entrypoint_args"`
	CmdArgs        []string          `json:"cmd_args" url:"cmd_args"`
	EnvVars        map[string]string `json:"env_vars" url:"env_vars"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Container) GetStatus() ContainerStatus {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *Container) GetImageName() string {
	if c == nil {
		return ""
	}
	return c.ImageName
}

func (c *Container) GetEntrypointArgs() []string {
	if c == nil {
		return nil
	}
	return c.EntrypointArgs
}

func (c *Container) GetCmdArgs() []string {
	if c == nil {
		return nil
	}
	return c.CmdArgs
}

func (c *Container) GetEnvVars() map[string]string {
	if c == nil {
		return nil
	}
	return c.EnvVars
}

func (c *Container) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Container) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Container) SetStatus(status ContainerStatus) {
	c.Status = status
	c.require(containerFieldStatus)
}

// SetImageName sets the ImageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Container) SetImageName(imageName string) {
	c.ImageName = imageName
	c.require(containerFieldImageName)
}

// SetEntrypointArgs sets the EntrypointArgs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Container) SetEntrypointArgs(entrypointArgs []string) {
	c.EntrypointArgs = entrypointArgs
	c.require(containerFieldEntrypointArgs)
}

// SetCmdArgs sets the CmdArgs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Container) SetCmdArgs(cmdArgs []string) {
	c.CmdArgs = cmdArgs
	c.require(containerFieldCmdArgs)
}

// SetEnvVars sets the EnvVars field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Container) SetEnvVars(envVars map[string]string) {
	c.EnvVars = envVars
	c.require(containerFieldEnvVars)
}

func (c *Container) UnmarshalJSON(data []byte) error {
	type unmarshaler Container
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Container(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Container) MarshalJSON() ([]byte, error) {
	type embed Container
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Container) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// 0 - STOPPED
// 1 - RUNNING
// 2 - UNKNOWN
type ContainerStatus string

const (
	ContainerStatusStopped ContainerStatus = "STOPPED"
	ContainerStatusRunning ContainerStatus = "RUNNING"
	ContainerStatusUnknown ContainerStatus = "UNKNOWN"
)

func NewContainerStatusFromString(s string) (ContainerStatus, error) {
	switch s {
	case "STOPPED":
		return ContainerStatusStopped, nil
	case "RUNNING":
		return ContainerStatusRunning, nil
	case "UNKNOWN":
		return ContainerStatusUnknown, nil
	}
	var t ContainerStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContainerStatus) Ptr() *ContainerStatus {
	return &c
}

var (
	execCommandResultFieldExitCode  = big.NewInt(1 << 0)
	execCommandResultFieldLogOutput = big.NewInt(1 << 1)
)

type ExecCommandResult struct {
	ExitCode int `json:"exit_code" url:"exit_code"`
	// Assumes UTF-8 encoding
	LogOutput string `json:"log_output" url:"log_output"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExecCommandResult) GetExitCode() int {
	if e == nil {
		return 0
	}
	return e.ExitCode
}

func (e *ExecCommandResult) GetLogOutput() string {
	if e == nil {
		return ""
	}
	return e.LogOutput
}

func (e *ExecCommandResult) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExecCommandResult) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetExitCode sets the ExitCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExecCommandResult) SetExitCode(exitCode int) {
	e.ExitCode = exitCode
	e.require(execCommandResultFieldExitCode)
}

// SetLogOutput sets the LogOutput field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ExecCommandResult) SetLogOutput(logOutput string) {
	e.LogOutput = logOutput
	e.require(execCommandResultFieldLogOutput)
}

func (e *ExecCommandResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecCommandResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecCommandResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecCommandResult) MarshalJSON() ([]byte, error) {
	type embed ExecCommandResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ExecCommandResult) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	fileArtifactDescriptionFieldPath        = big.NewInt(1 << 0)
	fileArtifactDescriptionFieldSize        = big.NewInt(1 << 1)
	fileArtifactDescriptionFieldTextPreview = big.NewInt(1 << 2)
)

type FileArtifactDescription struct {
	// Path relative to the file artifact
	Path string `json:"path" url:"path"`
	// Size of the file, in bytes
	Size int64 `json:"size" url:"size"`
	// A bit of text content, if the file allows (similar to UNIX's 'head')
	TextPreview *string `json:"text_preview,omitempty" url:"text_preview,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileArtifactDescription) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileArtifactDescription) GetSize() int64 {
	if f == nil {
		return 0
	}
	return f.Size
}

func (f *FileArtifactDescription) GetTextPreview() *string {
	if f == nil {
		return nil
	}
	return f.TextPreview
}

func (f *FileArtifactDescription) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileArtifactDescription) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileArtifactDescription) SetPath(path string) {
	f.Path = path
	f.require(fileArtifactDescriptionFieldPath)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileArtifactDescription) SetSize(size int64) {
	f.Size = size
	f.require(fileArtifactDescriptionFieldSize)
}

// SetTextPreview sets the TextPreview field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileArtifactDescription) SetTextPreview(textPreview *string) {
	f.TextPreview = textPreview
	f.require(fileArtifactDescriptionFieldTextPreview)
}

func (f *FileArtifactDescription) UnmarshalJSON(data []byte) error {
	type unmarshaler FileArtifactDescription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileArtifactDescription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileArtifactDescription) MarshalJSON() ([]byte, error) {
	type embed FileArtifactDescription
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileArtifactDescription) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Files Artifact identifier
var (
	fileArtifactReferenceFieldUuid = big.NewInt(1 << 0)
	fileArtifactReferenceFieldName = big.NewInt(1 << 1)
)

type FileArtifactReference struct {
	// UUID of the files artifact, for use when referencing it in the future
	Uuid string `json:"uuid" url:"uuid"`
	// UUID of the files artifact, for use when referencing it in the future
	Name string `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileArtifactReference) GetUuid() string {
	if f == nil {
		return ""
	}
	return f.Uuid
}

func (f *FileArtifactReference) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *FileArtifactReference) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileArtifactReference) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetUuid sets the Uuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileArtifactReference) SetUuid(uuid string) {
	f.Uuid = uuid
	f.require(fileArtifactReferenceFieldUuid)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileArtifactReference) SetName(name string) {
	f.Name = name
	f.require(fileArtifactReferenceFieldName)
}

func (f *FileArtifactReference) UnmarshalJSON(data []byte) error {
	type unmarshaler FileArtifactReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileArtifactReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileArtifactReference) MarshalJSON() ([]byte, error) {
	type embed FileArtifactReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileArtifactReference) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fileArtifactUploadResultFieldFileArtifactUploadResult = big.NewInt(1 << 0)
)

type FileArtifactUploadResult struct {
	FileArtifactUploadResult *FileArtifactUploadResultFileArtifactUploadResult `json:"file_artifact_upload_result,omitempty" url:"file_artifact_upload_result,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileArtifactUploadResult) GetFileArtifactUploadResult() *FileArtifactUploadResultFileArtifactUploadResult {
	if f == nil {
		return nil
	}
	return f.FileArtifactUploadResult
}

func (f *FileArtifactUploadResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileArtifactUploadResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFileArtifactUploadResult sets the FileArtifactUploadResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileArtifactUploadResult) SetFileArtifactUploadResult(fileArtifactUploadResult *FileArtifactUploadResultFileArtifactUploadResult) {
	f.FileArtifactUploadResult = fileArtifactUploadResult
	f.require(fileArtifactUploadResultFieldFileArtifactUploadResult)
}

func (f *FileArtifactUploadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileArtifactUploadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileArtifactUploadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileArtifactUploadResult) MarshalJSON() ([]byte, error) {
	type embed FileArtifactUploadResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileArtifactUploadResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileArtifactUploadResultFileArtifactUploadResult struct {
	FileArtifactReference *FileArtifactReference
	ResponseInfo          *ResponseInfo

	typ string
}

func (f *FileArtifactUploadResultFileArtifactUploadResult) GetFileArtifactReference() *FileArtifactReference {
	if f == nil {
		return nil
	}
	return f.FileArtifactReference
}

func (f *FileArtifactUploadResultFileArtifactUploadResult) GetResponseInfo() *ResponseInfo {
	if f == nil {
		return nil
	}
	return f.ResponseInfo
}

func (f *FileArtifactUploadResultFileArtifactUploadResult) UnmarshalJSON(data []byte) error {
	valueFileArtifactReference := new(FileArtifactReference)
	if err := json.Unmarshal(data, &valueFileArtifactReference); err == nil {
		f.typ = "FileArtifactReference"
		f.FileArtifactReference = valueFileArtifactReference
		return nil
	}
	valueResponseInfo := new(ResponseInfo)
	if err := json.Unmarshal(data, &valueResponseInfo); err == nil {
		f.typ = "ResponseInfo"
		f.ResponseInfo = valueResponseInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileArtifactUploadResultFileArtifactUploadResult) MarshalJSON() ([]byte, error) {
	if f.typ == "FileArtifactReference" || f.FileArtifactReference != nil {
		return json.Marshal(f.FileArtifactReference)
	}
	if f.typ == "ResponseInfo" || f.ResponseInfo != nil {
		return json.Marshal(f.ResponseInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileArtifactUploadResultFileArtifactUploadResultVisitor interface {
	VisitFileArtifactReference(*FileArtifactReference) error
	VisitResponseInfo(*ResponseInfo) error
}

func (f *FileArtifactUploadResultFileArtifactUploadResult) Accept(visitor FileArtifactUploadResultFileArtifactUploadResultVisitor) error {
	if f.typ == "FileArtifactReference" || f.FileArtifactReference != nil {
		return visitor.VisitFileArtifactReference(f.FileArtifactReference)
	}
	if f.typ == "ResponseInfo" || f.ResponseInfo != nil {
		return visitor.VisitResponseInfo(f.ResponseInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type HttpMethodAvailability string

const (
	HttpMethodAvailabilityGet  HttpMethodAvailability = "GET"
	HttpMethodAvailabilityPost HttpMethodAvailability = "POST"
)

func NewHttpMethodAvailabilityFromString(s string) (HttpMethodAvailability, error) {
	switch s {
	case "GET":
		return HttpMethodAvailabilityGet, nil
	case "POST":
		return HttpMethodAvailabilityPost, nil
	}
	var t HttpMethodAvailability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethodAvailability) Ptr() *HttpMethodAvailability {
	return &h
}

// 0 - ALWAYS
// 1 - MISSING
type ImageDownloadMode string

const (
	ImageDownloadModeAlways  ImageDownloadMode = "ALWAYS"
	ImageDownloadModeMissing ImageDownloadMode = "MISSING"
)

func NewImageDownloadModeFromString(s string) (ImageDownloadMode, error) {
	switch s {
	case "ALWAYS":
		return ImageDownloadModeAlways, nil
	case "MISSING":
		return ImageDownloadModeMissing, nil
	}
	var t ImageDownloadMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ImageDownloadMode) Ptr() *ImageDownloadMode {
	return &i
}

// 0 - NO_INSTRUCTIONS_CACHING
type KurtosisFeatureFlag = string

// Shared Objects (Used By Multiple Endpoints)
var (
	portFieldNumber              = big.NewInt(1 << 0)
	portFieldTransportProtocol   = big.NewInt(1 << 1)
	portFieldApplicationProtocol = big.NewInt(1 << 2)
	portFieldWaitTimeout         = big.NewInt(1 << 3)
)

type Port struct {
	Number              int               `json:"number" url:"number"`
	TransportProtocol   TransportProtocol `json:"transport_protocol" url:"transport_protocol"`
	ApplicationProtocol *string           `json:"application_protocol,omitempty" url:"application_protocol,omitempty"`
	// The wait timeout duration in string
	WaitTimeout *string `json:"wait_timeout,omitempty" url:"wait_timeout,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Port) GetNumber() int {
	if p == nil {
		return 0
	}
	return p.Number
}

func (p *Port) GetTransportProtocol() TransportProtocol {
	if p == nil {
		return ""
	}
	return p.TransportProtocol
}

func (p *Port) GetApplicationProtocol() *string {
	if p == nil {
		return nil
	}
	return p.ApplicationProtocol
}

func (p *Port) GetWaitTimeout() *string {
	if p == nil {
		return nil
	}
	return p.WaitTimeout
}

func (p *Port) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Port) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Port) SetNumber(number int) {
	p.Number = number
	p.require(portFieldNumber)
}

// SetTransportProtocol sets the TransportProtocol field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Port) SetTransportProtocol(transportProtocol TransportProtocol) {
	p.TransportProtocol = transportProtocol
	p.require(portFieldTransportProtocol)
}

// SetApplicationProtocol sets the ApplicationProtocol field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Port) SetApplicationProtocol(applicationProtocol *string) {
	p.ApplicationProtocol = applicationProtocol
	p.require(portFieldApplicationProtocol)
}

// SetWaitTimeout sets the WaitTimeout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Port) SetWaitTimeout(waitTimeout *string) {
	p.WaitTimeout = waitTimeout
	p.require(portFieldWaitTimeout)
}

func (p *Port) UnmarshalJSON(data []byte) error {
	type unmarshaler Port
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Port(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Port) MarshalJSON() ([]byte, error) {
	type embed Port
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Port) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	responseInfoFieldType    = big.NewInt(1 << 0)
	responseInfoFieldMessage = big.NewInt(1 << 1)
	responseInfoFieldCode    = big.NewInt(1 << 2)
)

type ResponseInfo struct {
	Type    ResponseType `json:"type" url:"type"`
	Message string       `json:"message" url:"message"`
	Code    int          `json:"code" url:"code"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseInfo) GetType() ResponseType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseInfo) GetMessage() string {
	if r == nil {
		return ""
	}
	return r.Message
}

func (r *ResponseInfo) GetCode() int {
	if r == nil {
		return 0
	}
	return r.Code
}

func (r *ResponseInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseInfo) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseInfo) SetType(type_ ResponseType) {
	r.Type = type_
	r.require(responseInfoFieldType)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseInfo) SetMessage(message string) {
	r.Message = message
	r.require(responseInfoFieldMessage)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseInfo) SetCode(code int) {
	r.Code = code
	r.require(responseInfoFieldCode)
}

func (r *ResponseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseInfo) MarshalJSON() ([]byte, error) {
	type embed ResponseInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseInfo) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseType string

const (
	ResponseTypeError   ResponseType = "ERROR"
	ResponseTypeInfo    ResponseType = "INFO"
	ResponseTypeWarning ResponseType = "WARNING"
)

func NewResponseTypeFromString(s string) (ResponseType, error) {
	switch s {
	case "ERROR":
		return ResponseTypeError, nil
	case "INFO":
		return ResponseTypeInfo, nil
	case "WARNING":
		return ResponseTypeWarning, nil
	}
	var t ResponseType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseType) Ptr() *ResponseType {
	return &r
}

// 0 - NEVER
// 1 - ALWAYS
type RestartPolicy string

const (
	RestartPolicyNever  RestartPolicy = "NEVER"
	RestartPolicyAlways RestartPolicy = "ALWAYS"
)

func NewRestartPolicyFromString(s string) (RestartPolicy, error) {
	switch s {
	case "NEVER":
		return RestartPolicyNever, nil
	case "ALWAYS":
		return RestartPolicyAlways, nil
	}
	var t RestartPolicy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RestartPolicy) Ptr() *RestartPolicy {
	return &r
}

// An service identifier is a collection of uuid, name and shortened uuid
var (
	serviceIdentifiersFieldServiceUuid   = big.NewInt(1 << 0)
	serviceIdentifiersFieldName          = big.NewInt(1 << 1)
	serviceIdentifiersFieldShortenedUuid = big.NewInt(1 << 2)
)

type ServiceIdentifiers struct {
	// UUID of the service
	ServiceUuid string `json:"service_uuid" url:"service_uuid"`
	// Name of the service
	Name string `json:"name" url:"name"`
	// The shortened uuid of the service
	ShortenedUuid string `json:"shortened_uuid" url:"shortened_uuid"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServiceIdentifiers) GetServiceUuid() string {
	if s == nil {
		return ""
	}
	return s.ServiceUuid
}

func (s *ServiceIdentifiers) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *ServiceIdentifiers) GetShortenedUuid() string {
	if s == nil {
		return ""
	}
	return s.ShortenedUuid
}

func (s *ServiceIdentifiers) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServiceIdentifiers) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetServiceUuid sets the ServiceUuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceIdentifiers) SetServiceUuid(serviceUuid string) {
	s.ServiceUuid = serviceUuid
	s.require(serviceIdentifiersFieldServiceUuid)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceIdentifiers) SetName(name string) {
	s.Name = name
	s.require(serviceIdentifiersFieldName)
}

// SetShortenedUuid sets the ShortenedUuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceIdentifiers) SetShortenedUuid(shortenedUuid string) {
	s.ShortenedUuid = shortenedUuid
	s.require(serviceIdentifiersFieldShortenedUuid)
}

func (s *ServiceIdentifiers) UnmarshalJSON(data []byte) error {
	type unmarshaler ServiceIdentifiers
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServiceIdentifiers(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServiceIdentifiers) MarshalJSON() ([]byte, error) {
	type embed ServiceIdentifiers
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ServiceIdentifiers) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	serviceInfoFieldServiceUuid   = big.NewInt(1 << 0)
	serviceInfoFieldPrivateIpAddr = big.NewInt(1 << 1)
	serviceInfoFieldPrivatePorts  = big.NewInt(1 << 2)
	serviceInfoFieldPublicIpAddr  = big.NewInt(1 << 3)
	serviceInfoFieldPublicPorts   = big.NewInt(1 << 4)
	serviceInfoFieldName          = big.NewInt(1 << 5)
	serviceInfoFieldShortenedUuid = big.NewInt(1 << 6)
	serviceInfoFieldServiceStatus = big.NewInt(1 << 7)
	serviceInfoFieldContainer     = big.NewInt(1 << 8)
)

type ServiceInfo struct {
	// UUID of the service
	ServiceUuid string `json:"service_uuid" url:"service_uuid"`
	// The IP address of the service inside the enclave
	PrivateIpAddr string           `json:"private_ip_addr" url:"private_ip_addr"`
	PrivatePorts  map[string]*Port `json:"private_ports" url:"private_ports"`
	// Public IP address *outside* the enclave where the service is reachable
	// NOTE: Will be empty if the service isn't running, the service didn't define any ports, or the backend doesn't support reporting public service info
	PublicIpAddr *string          `json:"public_ip_addr,omitempty" url:"public_ip_addr,omitempty"`
	PublicPorts  map[string]*Port `json:"public_ports,omitempty" url:"public_ports,omitempty"`
	// Name of the service
	Name string `json:"name" url:"name"`
	// Shortened uuid of the service
	ShortenedUuid string        `json:"shortened_uuid" url:"shortened_uuid"`
	ServiceStatus ServiceStatus `json:"service_status" url:"service_status"`
	Container     *Container    `json:"container" url:"container"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServiceInfo) GetServiceUuid() string {
	if s == nil {
		return ""
	}
	return s.ServiceUuid
}

func (s *ServiceInfo) GetPrivateIpAddr() string {
	if s == nil {
		return ""
	}
	return s.PrivateIpAddr
}

func (s *ServiceInfo) GetPrivatePorts() map[string]*Port {
	if s == nil {
		return nil
	}
	return s.PrivatePorts
}

func (s *ServiceInfo) GetPublicIpAddr() *string {
	if s == nil {
		return nil
	}
	return s.PublicIpAddr
}

func (s *ServiceInfo) GetPublicPorts() map[string]*Port {
	if s == nil {
		return nil
	}
	return s.PublicPorts
}

func (s *ServiceInfo) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *ServiceInfo) GetShortenedUuid() string {
	if s == nil {
		return ""
	}
	return s.ShortenedUuid
}

func (s *ServiceInfo) GetServiceStatus() ServiceStatus {
	if s == nil {
		return ""
	}
	return s.ServiceStatus
}

func (s *ServiceInfo) GetContainer() *Container {
	if s == nil {
		return nil
	}
	return s.Container
}

func (s *ServiceInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServiceInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetServiceUuid sets the ServiceUuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetServiceUuid(serviceUuid string) {
	s.ServiceUuid = serviceUuid
	s.require(serviceInfoFieldServiceUuid)
}

// SetPrivateIpAddr sets the PrivateIpAddr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetPrivateIpAddr(privateIpAddr string) {
	s.PrivateIpAddr = privateIpAddr
	s.require(serviceInfoFieldPrivateIpAddr)
}

// SetPrivatePorts sets the PrivatePorts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetPrivatePorts(privatePorts map[string]*Port) {
	s.PrivatePorts = privatePorts
	s.require(serviceInfoFieldPrivatePorts)
}

// SetPublicIpAddr sets the PublicIpAddr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetPublicIpAddr(publicIpAddr *string) {
	s.PublicIpAddr = publicIpAddr
	s.require(serviceInfoFieldPublicIpAddr)
}

// SetPublicPorts sets the PublicPorts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetPublicPorts(publicPorts map[string]*Port) {
	s.PublicPorts = publicPorts
	s.require(serviceInfoFieldPublicPorts)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetName(name string) {
	s.Name = name
	s.require(serviceInfoFieldName)
}

// SetShortenedUuid sets the ShortenedUuid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetShortenedUuid(shortenedUuid string) {
	s.ShortenedUuid = shortenedUuid
	s.require(serviceInfoFieldShortenedUuid)
}

// SetServiceStatus sets the ServiceStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetServiceStatus(serviceStatus ServiceStatus) {
	s.ServiceStatus = serviceStatus
	s.require(serviceInfoFieldServiceStatus)
}

// SetContainer sets the Container field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServiceInfo) SetContainer(container *Container) {
	s.Container = container
	s.require(serviceInfoFieldContainer)
}

func (s *ServiceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ServiceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServiceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServiceInfo) MarshalJSON() ([]byte, error) {
	type embed ServiceInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ServiceInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// 0 - STOPPED
// 1 - RUNNING
// 2 - UNKNOWN
type ServiceStatus string

const (
	ServiceStatusStopped ServiceStatus = "STOPPED"
	ServiceStatusRunning ServiceStatus = "RUNNING"
	ServiceStatusUnknown ServiceStatus = "UNKNOWN"
)

func NewServiceStatusFromString(s string) (ServiceStatus, error) {
	switch s {
	case "STOPPED":
		return ServiceStatusStopped, nil
	case "RUNNING":
		return ServiceStatusRunning, nil
	case "UNKNOWN":
		return ServiceStatusUnknown, nil
	}
	var t ServiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServiceStatus) Ptr() *ServiceStatus {
	return &s
}

var (
	starlarkDescriptionFieldPackageId              = big.NewInt(1 << 0)
	starlarkDescriptionFieldSerializedScript       = big.NewInt(1 << 1)
	starlarkDescriptionFieldSerializedParams       = big.NewInt(1 << 2)
	starlarkDescriptionFieldParallelism            = big.NewInt(1 << 3)
	starlarkDescriptionFieldRelativePathToMainFile = big.NewInt(1 << 4)
	starlarkDescriptionFieldMainFunctionName       = big.NewInt(1 << 5)
	starlarkDescriptionFieldExperimentalFeatures   = big.NewInt(1 << 6)
	starlarkDescriptionFieldRestartPolicy          = big.NewInt(1 << 7)
)

type StarlarkDescription struct {
	PackageId              string                `json:"package_id" url:"package_id"`
	SerializedScript       string                `json:"serialized_script" url:"serialized_script"`
	SerializedParams       string                `json:"serialized_params" url:"serialized_params"`
	Parallelism            int                   `json:"parallelism" url:"parallelism"`
	RelativePathToMainFile string                `json:"relative_path_to_main_file" url:"relative_path_to_main_file"`
	MainFunctionName       string                `json:"main_function_name" url:"main_function_name"`
	ExperimentalFeatures   []KurtosisFeatureFlag `json:"experimental_features" url:"experimental_features"`
	RestartPolicy          RestartPolicy         `json:"restart_policy" url:"restart_policy"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StarlarkDescription) GetPackageId() string {
	if s == nil {
		return ""
	}
	return s.PackageId
}

func (s *StarlarkDescription) GetSerializedScript() string {
	if s == nil {
		return ""
	}
	return s.SerializedScript
}

func (s *StarlarkDescription) GetSerializedParams() string {
	if s == nil {
		return ""
	}
	return s.SerializedParams
}

func (s *StarlarkDescription) GetParallelism() int {
	if s == nil {
		return 0
	}
	return s.Parallelism
}

func (s *StarlarkDescription) GetRelativePathToMainFile() string {
	if s == nil {
		return ""
	}
	return s.RelativePathToMainFile
}

func (s *StarlarkDescription) GetMainFunctionName() string {
	if s == nil {
		return ""
	}
	return s.MainFunctionName
}

func (s *StarlarkDescription) GetExperimentalFeatures() []KurtosisFeatureFlag {
	if s == nil {
		return nil
	}
	return s.ExperimentalFeatures
}

func (s *StarlarkDescription) GetRestartPolicy() RestartPolicy {
	if s == nil {
		return ""
	}
	return s.RestartPolicy
}

func (s *StarlarkDescription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StarlarkDescription) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetPackageId sets the PackageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetPackageId(packageId string) {
	s.PackageId = packageId
	s.require(starlarkDescriptionFieldPackageId)
}

// SetSerializedScript sets the SerializedScript field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetSerializedScript(serializedScript string) {
	s.SerializedScript = serializedScript
	s.require(starlarkDescriptionFieldSerializedScript)
}

// SetSerializedParams sets the SerializedParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetSerializedParams(serializedParams string) {
	s.SerializedParams = serializedParams
	s.require(starlarkDescriptionFieldSerializedParams)
}

// SetParallelism sets the Parallelism field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetParallelism(parallelism int) {
	s.Parallelism = parallelism
	s.require(starlarkDescriptionFieldParallelism)
}

// SetRelativePathToMainFile sets the RelativePathToMainFile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetRelativePathToMainFile(relativePathToMainFile string) {
	s.RelativePathToMainFile = relativePathToMainFile
	s.require(starlarkDescriptionFieldRelativePathToMainFile)
}

// SetMainFunctionName sets the MainFunctionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetMainFunctionName(mainFunctionName string) {
	s.MainFunctionName = mainFunctionName
	s.require(starlarkDescriptionFieldMainFunctionName)
}

// SetExperimentalFeatures sets the ExperimentalFeatures field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetExperimentalFeatures(experimentalFeatures []KurtosisFeatureFlag) {
	s.ExperimentalFeatures = experimentalFeatures
	s.require(starlarkDescriptionFieldExperimentalFeatures)
}

// SetRestartPolicy sets the RestartPolicy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkDescription) SetRestartPolicy(restartPolicy RestartPolicy) {
	s.RestartPolicy = restartPolicy
	s.require(starlarkDescriptionFieldRestartPolicy)
}

func (s *StarlarkDescription) UnmarshalJSON(data []byte) error {
	type unmarshaler StarlarkDescription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StarlarkDescription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StarlarkDescription) MarshalJSON() ([]byte, error) {
	type embed StarlarkDescription
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StarlarkDescription) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Starlark Execution Logs
type StarlarkRunLogs = []*StarlarkRunResponseLine

var (
	starlarkRunResponseFieldStarlarkExecutionLogs = big.NewInt(1 << 0)
)

type StarlarkRunResponse struct {
	StarlarkExecutionLogs *StarlarkRunResponseStarlarkExecutionLogs `json:"starlark_execution_logs,omitempty" url:"starlark_execution_logs,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StarlarkRunResponse) GetStarlarkExecutionLogs() *StarlarkRunResponseStarlarkExecutionLogs {
	if s == nil {
		return nil
	}
	return s.StarlarkExecutionLogs
}

func (s *StarlarkRunResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StarlarkRunResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetStarlarkExecutionLogs sets the StarlarkExecutionLogs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StarlarkRunResponse) SetStarlarkExecutionLogs(starlarkExecutionLogs *StarlarkRunResponseStarlarkExecutionLogs) {
	s.StarlarkExecutionLogs = starlarkExecutionLogs
	s.require(starlarkRunResponseFieldStarlarkExecutionLogs)
}

func (s *StarlarkRunResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler StarlarkRunResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StarlarkRunResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StarlarkRunResponse) MarshalJSON() ([]byte, error) {
	type embed StarlarkRunResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StarlarkRunResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StarlarkRunResponseStarlarkExecutionLogs struct {
	AsyncStarlarkExecutionLogs *AsyncStarlarkExecutionLogs
	StarlarkRunLogs            StarlarkRunLogs

	typ string
}

func (s *StarlarkRunResponseStarlarkExecutionLogs) GetAsyncStarlarkExecutionLogs() *AsyncStarlarkExecutionLogs {
	if s == nil {
		return nil
	}
	return s.AsyncStarlarkExecutionLogs
}

func (s *StarlarkRunResponseStarlarkExecutionLogs) GetStarlarkRunLogs() StarlarkRunLogs {
	if s == nil {
		return nil
	}
	return s.StarlarkRunLogs
}

func (s *StarlarkRunResponseStarlarkExecutionLogs) UnmarshalJSON(data []byte) error {
	valueAsyncStarlarkExecutionLogs := new(AsyncStarlarkExecutionLogs)
	if err := json.Unmarshal(data, &valueAsyncStarlarkExecutionLogs); err == nil {
		s.typ = "AsyncStarlarkExecutionLogs"
		s.AsyncStarlarkExecutionLogs = valueAsyncStarlarkExecutionLogs
		return nil
	}
	var valueStarlarkRunLogs StarlarkRunLogs
	if err := json.Unmarshal(data, &valueStarlarkRunLogs); err == nil {
		s.typ = "StarlarkRunLogs"
		s.StarlarkRunLogs = valueStarlarkRunLogs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StarlarkRunResponseStarlarkExecutionLogs) MarshalJSON() ([]byte, error) {
	if s.typ == "AsyncStarlarkExecutionLogs" || s.AsyncStarlarkExecutionLogs != nil {
		return json.Marshal(s.AsyncStarlarkExecutionLogs)
	}
	if s.typ == "StarlarkRunLogs" || s.StarlarkRunLogs != nil {
		return json.Marshal(s.StarlarkRunLogs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StarlarkRunResponseStarlarkExecutionLogsVisitor interface {
	VisitAsyncStarlarkExecutionLogs(*AsyncStarlarkExecutionLogs) error
	VisitStarlarkRunLogs(StarlarkRunLogs) error
}

func (s *StarlarkRunResponseStarlarkExecutionLogs) Accept(visitor StarlarkRunResponseStarlarkExecutionLogsVisitor) error {
	if s.typ == "AsyncStarlarkExecutionLogs" || s.AsyncStarlarkExecutionLogs != nil {
		return visitor.VisitAsyncStarlarkExecutionLogs(s.AsyncStarlarkExecutionLogs)
	}
	if s.typ == "StarlarkRunLogs" || s.StarlarkRunLogs != nil {
		return visitor.VisitStarlarkRunLogs(s.StarlarkRunLogs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// 0 - TCP
// 1 - SCTP
// 2 - UDP
type TransportProtocol string

const (
	TransportProtocolTcp  TransportProtocol = "TCP"
	TransportProtocolSctp TransportProtocol = "SCTP"
	TransportProtocolUdp  TransportProtocol = "UDP"
)

func NewTransportProtocolFromString(s string) (TransportProtocol, error) {
	switch s {
	case "TCP":
		return TransportProtocolTcp, nil
	case "SCTP":
		return TransportProtocolSctp, nil
	case "UDP":
		return TransportProtocolUdp, nil
	}
	var t TransportProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransportProtocol) Ptr() *TransportProtocol {
	return &t
}
