// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: engine/engine_service.proto

package engine_apiconnect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	engine "github.com/kurtosis-tech/kurtosis/connect-go-server/gen/engine"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// EngineServiceName is the fully-qualified name of the EngineService service.
	EngineServiceName = "engine_api.EngineService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// EngineServiceGetEngineInfoProcedure is the fully-qualified name of the EngineService's
	// GetEngineInfo RPC.
	EngineServiceGetEngineInfoProcedure = "/engine_api.EngineService/GetEngineInfo"
	// EngineServiceGetEnclavesProcedure is the fully-qualified name of the EngineService's GetEnclaves
	// RPC.
	EngineServiceGetEnclavesProcedure = "/engine_api.EngineService/GetEnclaves"
	// EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure is the fully-qualified name of
	// the EngineService's GetExistingAndHistoricalEnclaveIdentifiers RPC.
	EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure = "/engine_api.EngineService/GetExistingAndHistoricalEnclaveIdentifiers"
	// EngineServiceStopEnclaveProcedure is the fully-qualified name of the EngineService's StopEnclave
	// RPC.
	EngineServiceStopEnclaveProcedure = "/engine_api.EngineService/StopEnclave"
	// EngineServiceDestroyEnclaveProcedure is the fully-qualified name of the EngineService's
	// DestroyEnclave RPC.
	EngineServiceDestroyEnclaveProcedure = "/engine_api.EngineService/DestroyEnclave"
	// EngineServiceCleanProcedure is the fully-qualified name of the EngineService's Clean RPC.
	EngineServiceCleanProcedure = "/engine_api.EngineService/Clean"
	// EngineServiceGetServiceLogsProcedure is the fully-qualified name of the EngineService's
	// GetServiceLogs RPC.
	EngineServiceGetServiceLogsProcedure = "/engine_api.EngineService/GetServiceLogs"
)

// EngineServiceClient is a client for the engine_api.EngineService service.
type EngineServiceClient interface {
	// Endpoint for getting information about the engine, which is also what we use to verify that the engine has become available
	GetEngineInfo(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEngineInfoResponse], error)
	// ==============================================================================================
	//
	//	Enclave Management
	//
	// ==============================================================================================
	// Creates a new Kurtosis Enclave
	//
	//	rpc CreateEnclave(CreateEnclaveArgs) returns (CreateEnclaveResponse) {};
	//	// Returns information about the existing enclaves
	GetEnclaves(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEnclavesResponse], error)
	// Returns information about all existing & historical enclaves
	GetExistingAndHistoricalEnclaveIdentifiers(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetExistingAndHistoricalEnclaveIdentifiersResponse], error)
	// // Stops all containers in an enclave
	StopEnclave(context.Context, *connect_go.Request[engine.StopEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error)
	// // Destroys an enclave, removing all artifacts associated with it
	DestroyEnclave(context.Context, *connect_go.Request[engine.DestroyEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error)
	// // Gets rid of old enclaves
	Clean(context.Context, *connect_go.Request[engine.CleanArgs]) (*connect_go.Response[engine.CleanResponse], error)
	// // Get service logs
	GetServiceLogs(context.Context, *connect_go.Request[engine.GetServiceLogsArgs]) (*connect_go.ServerStreamForClient[engine.GetServiceLogsResponse], error)
}

// NewEngineServiceClient constructs a client for the engine_api.EngineService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewEngineServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) EngineServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &engineServiceClient{
		getEngineInfo: connect_go.NewClient[emptypb.Empty, engine.GetEngineInfoResponse](
			httpClient,
			baseURL+EngineServiceGetEngineInfoProcedure,
			opts...,
		),
		getEnclaves: connect_go.NewClient[emptypb.Empty, engine.GetEnclavesResponse](
			httpClient,
			baseURL+EngineServiceGetEnclavesProcedure,
			opts...,
		),
		getExistingAndHistoricalEnclaveIdentifiers: connect_go.NewClient[emptypb.Empty, engine.GetExistingAndHistoricalEnclaveIdentifiersResponse](
			httpClient,
			baseURL+EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure,
			opts...,
		),
		stopEnclave: connect_go.NewClient[engine.StopEnclaveArgs, emptypb.Empty](
			httpClient,
			baseURL+EngineServiceStopEnclaveProcedure,
			opts...,
		),
		destroyEnclave: connect_go.NewClient[engine.DestroyEnclaveArgs, emptypb.Empty](
			httpClient,
			baseURL+EngineServiceDestroyEnclaveProcedure,
			opts...,
		),
		clean: connect_go.NewClient[engine.CleanArgs, engine.CleanResponse](
			httpClient,
			baseURL+EngineServiceCleanProcedure,
			opts...,
		),
		getServiceLogs: connect_go.NewClient[engine.GetServiceLogsArgs, engine.GetServiceLogsResponse](
			httpClient,
			baseURL+EngineServiceGetServiceLogsProcedure,
			opts...,
		),
	}
}

// engineServiceClient implements EngineServiceClient.
type engineServiceClient struct {
	getEngineInfo                              *connect_go.Client[emptypb.Empty, engine.GetEngineInfoResponse]
	getEnclaves                                *connect_go.Client[emptypb.Empty, engine.GetEnclavesResponse]
	getExistingAndHistoricalEnclaveIdentifiers *connect_go.Client[emptypb.Empty, engine.GetExistingAndHistoricalEnclaveIdentifiersResponse]
	stopEnclave                                *connect_go.Client[engine.StopEnclaveArgs, emptypb.Empty]
	destroyEnclave                             *connect_go.Client[engine.DestroyEnclaveArgs, emptypb.Empty]
	clean                                      *connect_go.Client[engine.CleanArgs, engine.CleanResponse]
	getServiceLogs                             *connect_go.Client[engine.GetServiceLogsArgs, engine.GetServiceLogsResponse]
}

// GetEngineInfo calls engine_api.EngineService.GetEngineInfo.
func (c *engineServiceClient) GetEngineInfo(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEngineInfoResponse], error) {
	return c.getEngineInfo.CallUnary(ctx, req)
}

// GetEnclaves calls engine_api.EngineService.GetEnclaves.
func (c *engineServiceClient) GetEnclaves(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEnclavesResponse], error) {
	return c.getEnclaves.CallUnary(ctx, req)
}

// GetExistingAndHistoricalEnclaveIdentifiers calls
// engine_api.EngineService.GetExistingAndHistoricalEnclaveIdentifiers.
func (c *engineServiceClient) GetExistingAndHistoricalEnclaveIdentifiers(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetExistingAndHistoricalEnclaveIdentifiersResponse], error) {
	return c.getExistingAndHistoricalEnclaveIdentifiers.CallUnary(ctx, req)
}

// StopEnclave calls engine_api.EngineService.StopEnclave.
func (c *engineServiceClient) StopEnclave(ctx context.Context, req *connect_go.Request[engine.StopEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error) {
	return c.stopEnclave.CallUnary(ctx, req)
}

// DestroyEnclave calls engine_api.EngineService.DestroyEnclave.
func (c *engineServiceClient) DestroyEnclave(ctx context.Context, req *connect_go.Request[engine.DestroyEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error) {
	return c.destroyEnclave.CallUnary(ctx, req)
}

// Clean calls engine_api.EngineService.Clean.
func (c *engineServiceClient) Clean(ctx context.Context, req *connect_go.Request[engine.CleanArgs]) (*connect_go.Response[engine.CleanResponse], error) {
	return c.clean.CallUnary(ctx, req)
}

// GetServiceLogs calls engine_api.EngineService.GetServiceLogs.
func (c *engineServiceClient) GetServiceLogs(ctx context.Context, req *connect_go.Request[engine.GetServiceLogsArgs]) (*connect_go.ServerStreamForClient[engine.GetServiceLogsResponse], error) {
	return c.getServiceLogs.CallServerStream(ctx, req)
}

// EngineServiceHandler is an implementation of the engine_api.EngineService service.
type EngineServiceHandler interface {
	// Endpoint for getting information about the engine, which is also what we use to verify that the engine has become available
	GetEngineInfo(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEngineInfoResponse], error)
	// ==============================================================================================
	//
	//	Enclave Management
	//
	// ==============================================================================================
	// Creates a new Kurtosis Enclave
	//
	//	rpc CreateEnclave(CreateEnclaveArgs) returns (CreateEnclaveResponse) {};
	//	// Returns information about the existing enclaves
	GetEnclaves(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEnclavesResponse], error)
	// Returns information about all existing & historical enclaves
	GetExistingAndHistoricalEnclaveIdentifiers(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetExistingAndHistoricalEnclaveIdentifiersResponse], error)
	// // Stops all containers in an enclave
	StopEnclave(context.Context, *connect_go.Request[engine.StopEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error)
	// // Destroys an enclave, removing all artifacts associated with it
	DestroyEnclave(context.Context, *connect_go.Request[engine.DestroyEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error)
	// // Gets rid of old enclaves
	Clean(context.Context, *connect_go.Request[engine.CleanArgs]) (*connect_go.Response[engine.CleanResponse], error)
	// // Get service logs
	GetServiceLogs(context.Context, *connect_go.Request[engine.GetServiceLogsArgs], *connect_go.ServerStream[engine.GetServiceLogsResponse]) error
}

// NewEngineServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewEngineServiceHandler(svc EngineServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	engineServiceGetEngineInfoHandler := connect_go.NewUnaryHandler(
		EngineServiceGetEngineInfoProcedure,
		svc.GetEngineInfo,
		opts...,
	)
	engineServiceGetEnclavesHandler := connect_go.NewUnaryHandler(
		EngineServiceGetEnclavesProcedure,
		svc.GetEnclaves,
		opts...,
	)
	engineServiceGetExistingAndHistoricalEnclaveIdentifiersHandler := connect_go.NewUnaryHandler(
		EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure,
		svc.GetExistingAndHistoricalEnclaveIdentifiers,
		opts...,
	)
	engineServiceStopEnclaveHandler := connect_go.NewUnaryHandler(
		EngineServiceStopEnclaveProcedure,
		svc.StopEnclave,
		opts...,
	)
	engineServiceDestroyEnclaveHandler := connect_go.NewUnaryHandler(
		EngineServiceDestroyEnclaveProcedure,
		svc.DestroyEnclave,
		opts...,
	)
	engineServiceCleanHandler := connect_go.NewUnaryHandler(
		EngineServiceCleanProcedure,
		svc.Clean,
		opts...,
	)
	engineServiceGetServiceLogsHandler := connect_go.NewServerStreamHandler(
		EngineServiceGetServiceLogsProcedure,
		svc.GetServiceLogs,
		opts...,
	)
	return "/engine_api.EngineService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case EngineServiceGetEngineInfoProcedure:
			engineServiceGetEngineInfoHandler.ServeHTTP(w, r)
		case EngineServiceGetEnclavesProcedure:
			engineServiceGetEnclavesHandler.ServeHTTP(w, r)
		case EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure:
			engineServiceGetExistingAndHistoricalEnclaveIdentifiersHandler.ServeHTTP(w, r)
		case EngineServiceStopEnclaveProcedure:
			engineServiceStopEnclaveHandler.ServeHTTP(w, r)
		case EngineServiceDestroyEnclaveProcedure:
			engineServiceDestroyEnclaveHandler.ServeHTTP(w, r)
		case EngineServiceCleanProcedure:
			engineServiceCleanHandler.ServeHTTP(w, r)
		case EngineServiceGetServiceLogsProcedure:
			engineServiceGetServiceLogsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedEngineServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedEngineServiceHandler struct{}

func (UnimplementedEngineServiceHandler) GetEngineInfo(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEngineInfoResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.GetEngineInfo is not implemented"))
}

func (UnimplementedEngineServiceHandler) GetEnclaves(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetEnclavesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.GetEnclaves is not implemented"))
}

func (UnimplementedEngineServiceHandler) GetExistingAndHistoricalEnclaveIdentifiers(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[engine.GetExistingAndHistoricalEnclaveIdentifiersResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.GetExistingAndHistoricalEnclaveIdentifiers is not implemented"))
}

func (UnimplementedEngineServiceHandler) StopEnclave(context.Context, *connect_go.Request[engine.StopEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.StopEnclave is not implemented"))
}

func (UnimplementedEngineServiceHandler) DestroyEnclave(context.Context, *connect_go.Request[engine.DestroyEnclaveArgs]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.DestroyEnclave is not implemented"))
}

func (UnimplementedEngineServiceHandler) Clean(context.Context, *connect_go.Request[engine.CleanArgs]) (*connect_go.Response[engine.CleanResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.Clean is not implemented"))
}

func (UnimplementedEngineServiceHandler) GetServiceLogs(context.Context, *connect_go.Request[engine.GetServiceLogsArgs], *connect_go.ServerStream[engine.GetServiceLogsResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("engine_api.EngineService.GetServiceLogs is not implemented"))
}
