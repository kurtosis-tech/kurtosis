// @generated by protoc-gen-es v1.3.0 with parameter "target=js+dts"
// @generated from file api_container_service.proto (package api_container_api, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum api_container_api.ServiceStatus
 */
export declare enum ServiceStatus {
  /**
   * @generated from enum value: STOPPED = 0;
   */
  STOPPED = 0,

  /**
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: UNKNOWN = 2;
   */
  UNKNOWN = 2,
}

/**
 * @generated from enum api_container_api.ImageDownloadMode
 */
export declare enum ImageDownloadMode {
  /**
   * @generated from enum value: always = 0;
   */
  always = 0,

  /**
   * @generated from enum value: missing = 1;
   */
  missing = 1,
}

/**
 * User services port forwarding
 *
 * @generated from enum api_container_api.Connect
 */
export declare enum Connect {
  /**
   * Best effort port forwarding
   *
   * @generated from enum value: CONNECT = 0;
   */
  CONNECT = 0,

  /**
   * Port forwarding disabled
   *
   * Starlark run fails if the ports cannot be forwarded.
   * MUST_CONNECT = 2;
   *
   * @generated from enum value: NO_CONNECT = 1;
   */
  NO_CONNECT = 1,
}

/**
 * @generated from enum api_container_api.KurtosisFeatureFlag
 */
export declare enum KurtosisFeatureFlag {
  /**
   * @generated from enum value: NO_INSTRUCTIONS_CACHING = 0;
   */
  NO_INSTRUCTIONS_CACHING = 0,
}

/**
 * @generated from enum api_container_api.RestartPolicy
 */
export declare enum RestartPolicy {
  /**
   * @generated from enum value: NEVER = 0;
   */
  NEVER = 0,

  /**
   * @generated from enum value: ALWAYS = 1;
   */
  ALWAYS = 1,
}

/**
 * ==============================================================================================
 *                           Shared Objects (Used By Multiple Endpoints)
 * ==============================================================================================
 *
 * @generated from message api_container_api.Port
 */
export declare class Port extends Message<Port> {
  /**
   * @generated from field: uint32 number = 1;
   */
  number: number;

  /**
   * The protocol that the port is listening on
   *
   * @generated from field: api_container_api.Port.TransportProtocol transport_protocol = 2;
   */
  transportProtocol: Port_TransportProtocol;

  /**
   * @generated from field: string maybe_application_protocol = 3;
   */
  maybeApplicationProtocol: string;

  /**
   * The wait timeout duration in string
   *
   * @generated from field: string maybe_wait_timeout = 4;
   */
  maybeWaitTimeout: string;

  constructor(data?: PartialMessage<Port>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.Port";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Port;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Port;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Port;

  static equals(a: Port | PlainMessage<Port> | undefined, b: Port | PlainMessage<Port> | undefined): boolean;
}

/**
 * @generated from enum api_container_api.Port.TransportProtocol
 */
export declare enum Port_TransportProtocol {
  /**
   * @generated from enum value: TCP = 0;
   */
  TCP = 0,

  /**
   * @generated from enum value: SCTP = 1;
   */
  SCTP = 1,

  /**
   * @generated from enum value: UDP = 2;
   */
  UDP = 2,
}

/**
 * @generated from message api_container_api.Container
 */
export declare class Container extends Message<Container> {
  /**
   * @generated from field: api_container_api.Container.Status status = 1;
   */
  status: Container_Status;

  /**
   * @generated from field: string image_name = 2;
   */
  imageName: string;

  /**
   * @generated from field: repeated string entrypoint_args = 3;
   */
  entrypointArgs: string[];

  /**
   * @generated from field: repeated string cmd_args = 4;
   */
  cmdArgs: string[];

  /**
   * @generated from field: map<string, string> env_vars = 5;
   */
  envVars: { [key: string]: string };

  constructor(data?: PartialMessage<Container>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.Container";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Container;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Container;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Container;

  static equals(a: Container | PlainMessage<Container> | undefined, b: Container | PlainMessage<Container> | undefined): boolean;
}

/**
 * @generated from enum api_container_api.Container.Status
 */
export declare enum Container_Status {
  /**
   * @generated from enum value: STOPPED = 0;
   */
  STOPPED = 0,

  /**
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: UNKNOWN = 2;
   */
  UNKNOWN = 2,
}

/**
 * @generated from message api_container_api.ServiceInfo
 */
export declare class ServiceInfo extends Message<ServiceInfo> {
  /**
   * UUID of the service
   *
   * @generated from field: string service_uuid = 1;
   */
  serviceUuid: string;

  /**
   * The IP address of the service inside the enclave
   *
   * @generated from field: string private_ip_addr = 2;
   */
  privateIpAddr: string;

  /**
   * The ports on which the service is reachable inside the enclave, specified in user_specified_port_id -> port_info
   * Will be exactly what was passed in at the time of starting the service
   *
   * @generated from field: map<string, api_container_api.Port> private_ports = 3;
   */
  privatePorts: { [key: string]: Port };

  /**
   * Public IP address *outside* the enclave where the service is reachable
   * NOTE: Will be empty if the service isn't running, the service didn't define any ports, or the backend doesn't support reporting public service info
   *
   * @generated from field: string maybe_public_ip_addr = 4;
   */
  maybePublicIpAddr: string;

  /**
   * Mapping defining the ports that the service can be reached at *outside* the enclave, in the user_defined_port_id -> port_info where user_defined_port_id
   *  corresponds to the ID that was passed in in AddServiceArgs
   * NOTE: Will be empty if the service isn't running, the service didn't define any ports, or the backend doesn't support reporting public service info
   *
   * @generated from field: map<string, api_container_api.Port> maybe_public_ports = 5;
   */
  maybePublicPorts: { [key: string]: Port };

  /**
   * Name of the service
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * Shortened uuid of the service
   *
   * @generated from field: string shortened_uuid = 7;
   */
  shortenedUuid: string;

  /**
   * Service status: stopped, running.
   *
   * @generated from field: api_container_api.ServiceStatus service_status = 8;
   */
  serviceStatus: ServiceStatus;

  /**
   * Docker container or Kubernetes pod container
   *
   * @generated from field: api_container_api.Container container = 9;
   */
  container?: Container;

  constructor(data?: PartialMessage<ServiceInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ServiceInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceInfo;

  static equals(a: ServiceInfo | PlainMessage<ServiceInfo> | undefined, b: ServiceInfo | PlainMessage<ServiceInfo> | undefined): boolean;
}

/**
 * @generated from message api_container_api.RunStarlarkScriptArgs
 */
export declare class RunStarlarkScriptArgs extends Message<RunStarlarkScriptArgs> {
  /**
   * @generated from field: string serialized_script = 1;
   */
  serializedScript: string;

  /**
   * @generated from field: optional string serialized_params = 2;
   */
  serializedParams?: string;

  /**
   * Defaults to false
   *
   * @generated from field: optional bool dry_run = 3;
   */
  dryRun?: boolean;

  /**
   * Defaults to 4
   *
   * @generated from field: optional int32 parallelism = 4;
   */
  parallelism?: number;

  /**
   * The name of the main function, the default value is "run"
   *
   * @generated from field: optional string main_function_name = 5;
   */
  mainFunctionName?: string;

  /**
   * @generated from field: repeated api_container_api.KurtosisFeatureFlag experimental_features = 6;
   */
  experimentalFeatures: KurtosisFeatureFlag[];

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_instance_id = 7;
   */
  cloudInstanceId?: string;

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_user_id = 8;
   */
  cloudUserId?: string;

  /**
   * Defaults to empty
   *
   * @generated from field: optional api_container_api.ImageDownloadMode image_download_mode = 9;
   */
  imageDownloadMode?: ImageDownloadMode;

  constructor(data?: PartialMessage<RunStarlarkScriptArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.RunStarlarkScriptArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunStarlarkScriptArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunStarlarkScriptArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunStarlarkScriptArgs;

  static equals(a: RunStarlarkScriptArgs | PlainMessage<RunStarlarkScriptArgs> | undefined, b: RunStarlarkScriptArgs | PlainMessage<RunStarlarkScriptArgs> | undefined): boolean;
}

/**
 * @generated from message api_container_api.RunStarlarkPackageArgs
 */
export declare class RunStarlarkPackageArgs extends Message<RunStarlarkPackageArgs> {
  /**
   * @generated from field: string package_id = 1;
   */
  packageId: string;

  /**
   * Deprecated: If the package is local, it should have been uploaded with UploadStarlarkPackage prior to calling
   * RunStarlarkPackage. If the package is remote and must be cloned within the APIC, use the standalone boolean flag
   * clone_package below
   *
   * @generated from oneof api_container_api.RunStarlarkPackageArgs.starlark_package_content
   */
  starlarkPackageContent: {
    /**
     * the payload of the local module
     *
     * @generated from field: bytes local = 3;
     */
    value: Uint8Array;
    case: "local";
  } | {
    /**
     * just a flag to indicate the module must be cloned inside the API
     *
     * @generated from field: bool remote = 4;
     */
    value: boolean;
    case: "remote";
  } | { case: undefined; value?: undefined };

  /**
   * Serialized parameters data for the Starlark package main function
   * This should be a valid JSON string
   *
   * @generated from field: optional string serialized_params = 5;
   */
  serializedParams?: string;

  /**
   * Defaults to false
   *
   * @generated from field: optional bool dry_run = 6;
   */
  dryRun?: boolean;

  /**
   * Defaults to 4
   *
   * @generated from field: optional int32 parallelism = 7;
   */
  parallelism?: number;

  /**
   * Whether the package should be cloned or not.
   * If false, then the package will be pulled from the APIC local package store. If it's a local package then is must
   * have been uploaded using UploadStarlarkPackage prior to calling RunStarlarkPackage.
   * If true, then the package will be cloned from GitHub before execution starts
   *
   * @generated from field: optional bool clone_package = 8;
   */
  clonePackage?: boolean;

  /**
   * The relative main file filepath, the default value is the "main.star" file in the root of a package
   *
   * @generated from field: optional string relative_path_to_main_file = 9;
   */
  relativePathToMainFile?: string;

  /**
   * The name of the main function, the default value is "run"
   *
   * @generated from field: optional string main_function_name = 10;
   */
  mainFunctionName?: string;

  /**
   * @generated from field: repeated api_container_api.KurtosisFeatureFlag experimental_features = 11;
   */
  experimentalFeatures: KurtosisFeatureFlag[];

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_instance_id = 12;
   */
  cloudInstanceId?: string;

  /**
   * Defaults to empty
   *
   * @generated from field: optional string cloud_user_id = 13;
   */
  cloudUserId?: string;

  /**
   * Defaults to empty
   *
   * @generated from field: optional api_container_api.ImageDownloadMode image_download_mode = 14;
   */
  imageDownloadMode?: ImageDownloadMode;

  constructor(data?: PartialMessage<RunStarlarkPackageArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.RunStarlarkPackageArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunStarlarkPackageArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunStarlarkPackageArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunStarlarkPackageArgs;

  static equals(a: RunStarlarkPackageArgs | PlainMessage<RunStarlarkPackageArgs> | undefined, b: RunStarlarkPackageArgs | PlainMessage<RunStarlarkPackageArgs> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                               Starlark Execution Response
 * ==============================================================================================
 *
 * @generated from message api_container_api.StarlarkRunResponseLine
 */
export declare class StarlarkRunResponseLine extends Message<StarlarkRunResponseLine> {
  /**
   * @generated from oneof api_container_api.StarlarkRunResponseLine.run_response_line
   */
  runResponseLine: {
    /**
     * @generated from field: api_container_api.StarlarkInstruction instruction = 1;
     */
    value: StarlarkInstruction;
    case: "instruction";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkError error = 2;
     */
    value: StarlarkError;
    case: "error";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkRunProgress progress_info = 3;
     */
    value: StarlarkRunProgress;
    case: "progressInfo";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkInstructionResult instruction_result = 4;
     */
    value: StarlarkInstructionResult;
    case: "instructionResult";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkRunFinishedEvent run_finished_event = 5;
     */
    value: StarlarkRunFinishedEvent;
    case: "runFinishedEvent";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkWarning warning = 6;
     */
    value: StarlarkWarning;
    case: "warning";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkInfo info = 7;
     */
    value: StarlarkInfo;
    case: "info";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<StarlarkRunResponseLine>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkRunResponseLine";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkRunResponseLine;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkRunResponseLine;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkRunResponseLine;

  static equals(a: StarlarkRunResponseLine | PlainMessage<StarlarkRunResponseLine> | undefined, b: StarlarkRunResponseLine | PlainMessage<StarlarkRunResponseLine> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkInfo
 */
export declare class StarlarkInfo extends Message<StarlarkInfo> {
  /**
   * @generated from field: string info_message = 1;
   */
  infoMessage: string;

  constructor(data?: PartialMessage<StarlarkInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInfo;

  static equals(a: StarlarkInfo | PlainMessage<StarlarkInfo> | undefined, b: StarlarkInfo | PlainMessage<StarlarkInfo> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkWarning
 */
export declare class StarlarkWarning extends Message<StarlarkWarning> {
  /**
   * @generated from field: string warning_message = 1;
   */
  warningMessage: string;

  constructor(data?: PartialMessage<StarlarkWarning>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkWarning";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkWarning;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkWarning;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkWarning;

  static equals(a: StarlarkWarning | PlainMessage<StarlarkWarning> | undefined, b: StarlarkWarning | PlainMessage<StarlarkWarning> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkInstruction
 */
export declare class StarlarkInstruction extends Message<StarlarkInstruction> {
  /**
   * @generated from field: api_container_api.StarlarkInstructionPosition position = 1;
   */
  position?: StarlarkInstructionPosition;

  /**
   * @generated from field: string instruction_name = 2;
   */
  instructionName: string;

  /**
   * @generated from field: repeated api_container_api.StarlarkInstructionArg arguments = 3;
   */
  arguments: StarlarkInstructionArg[];

  /**
   * @generated from field: string executable_instruction = 4;
   */
  executableInstruction: string;

  /**
   * @generated from field: bool is_skipped = 5;
   */
  isSkipped: boolean;

  constructor(data?: PartialMessage<StarlarkInstruction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkInstruction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstruction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstruction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstruction;

  static equals(a: StarlarkInstruction | PlainMessage<StarlarkInstruction> | undefined, b: StarlarkInstruction | PlainMessage<StarlarkInstruction> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkInstructionResult
 */
export declare class StarlarkInstructionResult extends Message<StarlarkInstructionResult> {
  /**
   * @generated from field: string serialized_instruction_result = 1;
   */
  serializedInstructionResult: string;

  constructor(data?: PartialMessage<StarlarkInstructionResult>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkInstructionResult";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstructionResult;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstructionResult;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstructionResult;

  static equals(a: StarlarkInstructionResult | PlainMessage<StarlarkInstructionResult> | undefined, b: StarlarkInstructionResult | PlainMessage<StarlarkInstructionResult> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkInstructionArg
 */
export declare class StarlarkInstructionArg extends Message<StarlarkInstructionArg> {
  /**
   * @generated from field: string serialized_arg_value = 1;
   */
  serializedArgValue: string;

  /**
   * @generated from field: optional string arg_name = 2;
   */
  argName?: string;

  /**
   * @generated from field: bool is_representative = 3;
   */
  isRepresentative: boolean;

  constructor(data?: PartialMessage<StarlarkInstructionArg>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkInstructionArg";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstructionArg;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstructionArg;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstructionArg;

  static equals(a: StarlarkInstructionArg | PlainMessage<StarlarkInstructionArg> | undefined, b: StarlarkInstructionArg | PlainMessage<StarlarkInstructionArg> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkInstructionPosition
 */
export declare class StarlarkInstructionPosition extends Message<StarlarkInstructionPosition> {
  /**
   * @generated from field: string filename = 1;
   */
  filename: string;

  /**
   * @generated from field: int32 line = 2;
   */
  line: number;

  /**
   * @generated from field: int32 column = 3;
   */
  column: number;

  constructor(data?: PartialMessage<StarlarkInstructionPosition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkInstructionPosition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInstructionPosition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInstructionPosition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInstructionPosition;

  static equals(a: StarlarkInstructionPosition | PlainMessage<StarlarkInstructionPosition> | undefined, b: StarlarkInstructionPosition | PlainMessage<StarlarkInstructionPosition> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkError
 */
export declare class StarlarkError extends Message<StarlarkError> {
  /**
   * @generated from oneof api_container_api.StarlarkError.error
   */
  error: {
    /**
     * @generated from field: api_container_api.StarlarkInterpretationError interpretation_error = 1;
     */
    value: StarlarkInterpretationError;
    case: "interpretationError";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkValidationError validation_error = 2;
     */
    value: StarlarkValidationError;
    case: "validationError";
  } | {
    /**
     * @generated from field: api_container_api.StarlarkExecutionError execution_error = 3;
     */
    value: StarlarkExecutionError;
    case: "executionError";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<StarlarkError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkError;

  static equals(a: StarlarkError | PlainMessage<StarlarkError> | undefined, b: StarlarkError | PlainMessage<StarlarkError> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkInterpretationError
 */
export declare class StarlarkInterpretationError extends Message<StarlarkInterpretationError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage: string;

  constructor(data?: PartialMessage<StarlarkInterpretationError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkInterpretationError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkInterpretationError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkInterpretationError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkInterpretationError;

  static equals(a: StarlarkInterpretationError | PlainMessage<StarlarkInterpretationError> | undefined, b: StarlarkInterpretationError | PlainMessage<StarlarkInterpretationError> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkValidationError
 */
export declare class StarlarkValidationError extends Message<StarlarkValidationError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage: string;

  constructor(data?: PartialMessage<StarlarkValidationError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkValidationError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkValidationError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkValidationError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkValidationError;

  static equals(a: StarlarkValidationError | PlainMessage<StarlarkValidationError> | undefined, b: StarlarkValidationError | PlainMessage<StarlarkValidationError> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkExecutionError
 */
export declare class StarlarkExecutionError extends Message<StarlarkExecutionError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage: string;

  constructor(data?: PartialMessage<StarlarkExecutionError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkExecutionError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkExecutionError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkExecutionError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkExecutionError;

  static equals(a: StarlarkExecutionError | PlainMessage<StarlarkExecutionError> | undefined, b: StarlarkExecutionError | PlainMessage<StarlarkExecutionError> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkRunProgress
 */
export declare class StarlarkRunProgress extends Message<StarlarkRunProgress> {
  /**
   * @generated from field: repeated string current_step_info = 1;
   */
  currentStepInfo: string[];

  /**
   * @generated from field: uint32 total_steps = 2;
   */
  totalSteps: number;

  /**
   * @generated from field: uint32 current_step_number = 3;
   */
  currentStepNumber: number;

  constructor(data?: PartialMessage<StarlarkRunProgress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkRunProgress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkRunProgress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkRunProgress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkRunProgress;

  static equals(a: StarlarkRunProgress | PlainMessage<StarlarkRunProgress> | undefined, b: StarlarkRunProgress | PlainMessage<StarlarkRunProgress> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StarlarkRunFinishedEvent
 */
export declare class StarlarkRunFinishedEvent extends Message<StarlarkRunFinishedEvent> {
  /**
   * @generated from field: bool is_run_successful = 1;
   */
  isRunSuccessful: boolean;

  /**
   * @generated from field: optional string serialized_output = 2;
   */
  serializedOutput?: string;

  constructor(data?: PartialMessage<StarlarkRunFinishedEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StarlarkRunFinishedEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StarlarkRunFinishedEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StarlarkRunFinishedEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StarlarkRunFinishedEvent;

  static equals(a: StarlarkRunFinishedEvent | PlainMessage<StarlarkRunFinishedEvent> | undefined, b: StarlarkRunFinishedEvent | PlainMessage<StarlarkRunFinishedEvent> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                                          Get Services
 * ==============================================================================================
 *
 * @generated from message api_container_api.GetServicesArgs
 */
export declare class GetServicesArgs extends Message<GetServicesArgs> {
  /**
   * "Set" of identifiers to fetch info for
   * If empty, will fetch info for all services
   *
   * @generated from field: map<string, bool> service_identifiers = 1;
   */
  serviceIdentifiers: { [key: string]: boolean };

  constructor(data?: PartialMessage<GetServicesArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.GetServicesArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServicesArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServicesArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServicesArgs;

  static equals(a: GetServicesArgs | PlainMessage<GetServicesArgs> | undefined, b: GetServicesArgs | PlainMessage<GetServicesArgs> | undefined): boolean;
}

/**
 * @generated from message api_container_api.GetServicesResponse
 */
export declare class GetServicesResponse extends Message<GetServicesResponse> {
  /**
   * "Set" from identifiers -> info about the service
   *
   * @generated from field: map<string, api_container_api.ServiceInfo> service_info = 1;
   */
  serviceInfo: { [key: string]: ServiceInfo };

  constructor(data?: PartialMessage<GetServicesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.GetServicesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServicesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServicesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServicesResponse;

  static equals(a: GetServicesResponse | PlainMessage<GetServicesResponse> | undefined, b: GetServicesResponse | PlainMessage<GetServicesResponse> | undefined): boolean;
}

/**
 * An service identifier is a collection of uuid, name and shortened uuid
 *
 * @generated from message api_container_api.ServiceIdentifiers
 */
export declare class ServiceIdentifiers extends Message<ServiceIdentifiers> {
  /**
   * UUID of the service
   *
   * @generated from field: string service_uuid = 1;
   */
  serviceUuid: string;

  /**
   * Name of the service
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The shortened uuid of the service
   *
   * @generated from field: string shortened_uuid = 3;
   */
  shortenedUuid: string;

  constructor(data?: PartialMessage<ServiceIdentifiers>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ServiceIdentifiers";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceIdentifiers;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceIdentifiers;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceIdentifiers;

  static equals(a: ServiceIdentifiers | PlainMessage<ServiceIdentifiers> | undefined, b: ServiceIdentifiers | PlainMessage<ServiceIdentifiers> | undefined): boolean;
}

/**
 * @generated from message api_container_api.GetExistingAndHistoricalServiceIdentifiersResponse
 */
export declare class GetExistingAndHistoricalServiceIdentifiersResponse extends Message<GetExistingAndHistoricalServiceIdentifiersResponse> {
  /**
   * @generated from field: repeated api_container_api.ServiceIdentifiers allIdentifiers = 1;
   */
  allIdentifiers: ServiceIdentifiers[];

  constructor(data?: PartialMessage<GetExistingAndHistoricalServiceIdentifiersResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.GetExistingAndHistoricalServiceIdentifiersResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExistingAndHistoricalServiceIdentifiersResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExistingAndHistoricalServiceIdentifiersResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExistingAndHistoricalServiceIdentifiersResponse;

  static equals(a: GetExistingAndHistoricalServiceIdentifiersResponse | PlainMessage<GetExistingAndHistoricalServiceIdentifiersResponse> | undefined, b: GetExistingAndHistoricalServiceIdentifiersResponse | PlainMessage<GetExistingAndHistoricalServiceIdentifiersResponse> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                                          Exec Command
 * ==============================================================================================
 *
 * @generated from message api_container_api.ExecCommandArgs
 */
export declare class ExecCommandArgs extends Message<ExecCommandArgs> {
  /**
   * The service identifier of the container that the command should be executed in
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier: string;

  /**
   * @generated from field: repeated string command_args = 2;
   */
  commandArgs: string[];

  constructor(data?: PartialMessage<ExecCommandArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ExecCommandArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecCommandArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecCommandArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecCommandArgs;

  static equals(a: ExecCommandArgs | PlainMessage<ExecCommandArgs> | undefined, b: ExecCommandArgs | PlainMessage<ExecCommandArgs> | undefined): boolean;
}

/**
 * @generated from message api_container_api.ExecCommandResponse
 */
export declare class ExecCommandResponse extends Message<ExecCommandResponse> {
  /**
   * @generated from field: int32 exit_code = 1;
   */
  exitCode: number;

  /**
   * Assumes UTF-8 encoding
   *
   * @generated from field: string log_output = 2;
   */
  logOutput: string;

  constructor(data?: PartialMessage<ExecCommandResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ExecCommandResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecCommandResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecCommandResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecCommandResponse;

  static equals(a: ExecCommandResponse | PlainMessage<ExecCommandResponse> | undefined, b: ExecCommandResponse | PlainMessage<ExecCommandResponse> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                             Wait For HTTP Get Endpoint Availability
 * ==============================================================================================
 *
 * @generated from message api_container_api.WaitForHttpGetEndpointAvailabilityArgs
 */
export declare class WaitForHttpGetEndpointAvailabilityArgs extends Message<WaitForHttpGetEndpointAvailabilityArgs> {
  /**
   * The identifier of the service to check.
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier: string;

  /**
   * The port of the service to check. For instance 8080
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The path of the service to check. It mustn't start with the first slash. For instance `service/health`
   *
   * @generated from field: optional string path = 3;
   */
  path?: string;

  /**
   * The number of milliseconds to wait until executing the first HTTP call
   *
   * @generated from field: optional uint32 initial_delay_milliseconds = 4;
   */
  initialDelayMilliseconds?: number;

  /**
   * Max number of HTTP call attempts that this will execute until giving up and returning an error
   *
   * @generated from field: optional uint32 retries = 5;
   */
  retries?: number;

  /**
   * Number of milliseconds to wait between retries
   *
   * @generated from field: optional uint32 retries_delay_milliseconds = 6;
   */
  retriesDelayMilliseconds?: number;

  /**
   * If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
   *
   * @generated from field: optional string body_text = 7;
   */
  bodyText?: string;

  constructor(data?: PartialMessage<WaitForHttpGetEndpointAvailabilityArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.WaitForHttpGetEndpointAvailabilityArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitForHttpGetEndpointAvailabilityArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitForHttpGetEndpointAvailabilityArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitForHttpGetEndpointAvailabilityArgs;

  static equals(a: WaitForHttpGetEndpointAvailabilityArgs | PlainMessage<WaitForHttpGetEndpointAvailabilityArgs> | undefined, b: WaitForHttpGetEndpointAvailabilityArgs | PlainMessage<WaitForHttpGetEndpointAvailabilityArgs> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                           Wait For HTTP Post Endpoint Availability
 * ==============================================================================================
 *
 * @generated from message api_container_api.WaitForHttpPostEndpointAvailabilityArgs
 */
export declare class WaitForHttpPostEndpointAvailabilityArgs extends Message<WaitForHttpPostEndpointAvailabilityArgs> {
  /**
   * The identifier of the service to check.
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier: string;

  /**
   * The port of the service to check. For instance 8080
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The path of the service to check. It mustn't start with the first slash. For instance `service/health`
   *
   * @generated from field: optional string path = 3;
   */
  path?: string;

  /**
   * The content of the request body.
   *
   * @generated from field: optional string request_body = 4;
   */
  requestBody?: string;

  /**
   * The number of milliseconds to wait until executing the first HTTP call
   *
   * @generated from field: optional uint32 initial_delay_milliseconds = 5;
   */
  initialDelayMilliseconds?: number;

  /**
   * Max number of HTTP call attempts that this will execute until giving up and returning an error
   *
   * @generated from field: optional uint32 retries = 6;
   */
  retries?: number;

  /**
   * Number of milliseconds to wait between retries
   *
   * @generated from field: optional uint32 retries_delay_milliseconds = 7;
   */
  retriesDelayMilliseconds?: number;

  /**
   * If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
   *
   * @generated from field: optional string body_text = 8;
   */
  bodyText?: string;

  constructor(data?: PartialMessage<WaitForHttpPostEndpointAvailabilityArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.WaitForHttpPostEndpointAvailabilityArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitForHttpPostEndpointAvailabilityArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitForHttpPostEndpointAvailabilityArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitForHttpPostEndpointAvailabilityArgs;

  static equals(a: WaitForHttpPostEndpointAvailabilityArgs | PlainMessage<WaitForHttpPostEndpointAvailabilityArgs> | undefined, b: WaitForHttpPostEndpointAvailabilityArgs | PlainMessage<WaitForHttpPostEndpointAvailabilityArgs> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                                          Streamed Data Chunk
 * ==============================================================================================
 *
 * @generated from message api_container_api.StreamedDataChunk
 */
export declare class StreamedDataChunk extends Message<StreamedDataChunk> {
  /**
   * Chunk of the overall files artifact bytes
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;

  /**
   * Hash of the PREVIOUS chunk, or empty string is this is the first chunk
   * Referencing the previous chunk via its hash allows Kurtosis to validate
   * the consistency of the data in case some chunk were not received
   *
   * @generated from field: string previous_chunk_hash = 2;
   */
  previousChunkHash: string;

  /**
   * Additional metadata about the item being streamed
   *
   * @generated from field: api_container_api.DataChunkMetadata metadata = 3;
   */
  metadata?: DataChunkMetadata;

  constructor(data?: PartialMessage<StreamedDataChunk>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StreamedDataChunk";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamedDataChunk;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamedDataChunk;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamedDataChunk;

  static equals(a: StreamedDataChunk | PlainMessage<StreamedDataChunk> | undefined, b: StreamedDataChunk | PlainMessage<StreamedDataChunk> | undefined): boolean;
}

/**
 * @generated from message api_container_api.DataChunkMetadata
 */
export declare class DataChunkMetadata extends Message<DataChunkMetadata> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  constructor(data?: PartialMessage<DataChunkMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.DataChunkMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataChunkMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataChunkMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataChunkMetadata;

  static equals(a: DataChunkMetadata | PlainMessage<DataChunkMetadata> | undefined, b: DataChunkMetadata | PlainMessage<DataChunkMetadata> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                                          Upload Files Artifact
 * ==============================================================================================
 *
 * @generated from message api_container_api.UploadFilesArtifactResponse
 */
export declare class UploadFilesArtifactResponse extends Message<UploadFilesArtifactResponse> {
  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string uuid = 1;
   */
  uuid: string;

  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string name = 2;
   */
  name: string;

  constructor(data?: PartialMessage<UploadFilesArtifactResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.UploadFilesArtifactResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadFilesArtifactResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadFilesArtifactResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadFilesArtifactResponse;

  static equals(a: UploadFilesArtifactResponse | PlainMessage<UploadFilesArtifactResponse> | undefined, b: UploadFilesArtifactResponse | PlainMessage<UploadFilesArtifactResponse> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                                          Download Files Artifact
 * ==============================================================================================
 *
 * @generated from message api_container_api.DownloadFilesArtifactArgs
 */
export declare class DownloadFilesArtifactArgs extends Message<DownloadFilesArtifactArgs> {
  /**
   * Files identifier to get bytes for
   *
   * @generated from field: string identifier = 1;
   */
  identifier: string;

  constructor(data?: PartialMessage<DownloadFilesArtifactArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.DownloadFilesArtifactArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadFilesArtifactArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadFilesArtifactArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadFilesArtifactArgs;

  static equals(a: DownloadFilesArtifactArgs | PlainMessage<DownloadFilesArtifactArgs> | undefined, b: DownloadFilesArtifactArgs | PlainMessage<DownloadFilesArtifactArgs> | undefined): boolean;
}

/**
 * ==============================================================================================
 *                                        Store Web Files Artifact
 * ==============================================================================================
 *
 * @generated from message api_container_api.StoreWebFilesArtifactArgs
 */
export declare class StoreWebFilesArtifactArgs extends Message<StoreWebFilesArtifactArgs> {
  /**
   * URL to download the artifact from
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The name of the files artifact
   *
   * @generated from field: string name = 2;
   */
  name: string;

  constructor(data?: PartialMessage<StoreWebFilesArtifactArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StoreWebFilesArtifactArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreWebFilesArtifactArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactArgs;

  static equals(a: StoreWebFilesArtifactArgs | PlainMessage<StoreWebFilesArtifactArgs> | undefined, b: StoreWebFilesArtifactArgs | PlainMessage<StoreWebFilesArtifactArgs> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StoreWebFilesArtifactResponse
 */
export declare class StoreWebFilesArtifactResponse extends Message<StoreWebFilesArtifactResponse> {
  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string uuid = 1;
   */
  uuid: string;

  constructor(data?: PartialMessage<StoreWebFilesArtifactResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StoreWebFilesArtifactResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreWebFilesArtifactResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreWebFilesArtifactResponse;

  static equals(a: StoreWebFilesArtifactResponse | PlainMessage<StoreWebFilesArtifactResponse> | undefined, b: StoreWebFilesArtifactResponse | PlainMessage<StoreWebFilesArtifactResponse> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StoreFilesArtifactFromServiceArgs
 */
export declare class StoreFilesArtifactFromServiceArgs extends Message<StoreFilesArtifactFromServiceArgs> {
  /**
   * Identifier that will be used to identify the service where the source files will be copied from
   *
   * @generated from field: string service_identifier = 1;
   */
  serviceIdentifier: string;

  /**
   * The absolute source path where the source files will be copied from
   *
   * @generated from field: string source_path = 2;
   */
  sourcePath: string;

  /**
   * The name of the files artifact
   *
   * @generated from field: string name = 3;
   */
  name: string;

  constructor(data?: PartialMessage<StoreFilesArtifactFromServiceArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StoreFilesArtifactFromServiceArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreFilesArtifactFromServiceArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceArgs;

  static equals(a: StoreFilesArtifactFromServiceArgs | PlainMessage<StoreFilesArtifactFromServiceArgs> | undefined, b: StoreFilesArtifactFromServiceArgs | PlainMessage<StoreFilesArtifactFromServiceArgs> | undefined): boolean;
}

/**
 * @generated from message api_container_api.StoreFilesArtifactFromServiceResponse
 */
export declare class StoreFilesArtifactFromServiceResponse extends Message<StoreFilesArtifactFromServiceResponse> {
  /**
   * UUID of the files artifact, for use when referencing it in the future
   *
   * @generated from field: string uuid = 1;
   */
  uuid: string;

  constructor(data?: PartialMessage<StoreFilesArtifactFromServiceResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.StoreFilesArtifactFromServiceResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreFilesArtifactFromServiceResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreFilesArtifactFromServiceResponse;

  static equals(a: StoreFilesArtifactFromServiceResponse | PlainMessage<StoreFilesArtifactFromServiceResponse> | undefined, b: StoreFilesArtifactFromServiceResponse | PlainMessage<StoreFilesArtifactFromServiceResponse> | undefined): boolean;
}

/**
 * @generated from message api_container_api.FilesArtifactNameAndUuid
 */
export declare class FilesArtifactNameAndUuid extends Message<FilesArtifactNameAndUuid> {
  /**
   * A string representing the name of the file
   *
   * @generated from field: string fileName = 1;
   */
  fileName: string;

  /**
   * A string representing the uuid of the file
   *
   * @generated from field: string fileUuid = 2;
   */
  fileUuid: string;

  constructor(data?: PartialMessage<FilesArtifactNameAndUuid>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.FilesArtifactNameAndUuid";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilesArtifactNameAndUuid;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilesArtifactNameAndUuid;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilesArtifactNameAndUuid;

  static equals(a: FilesArtifactNameAndUuid | PlainMessage<FilesArtifactNameAndUuid> | undefined, b: FilesArtifactNameAndUuid | PlainMessage<FilesArtifactNameAndUuid> | undefined): boolean;
}

/**
 * @generated from message api_container_api.ListFilesArtifactNamesAndUuidsResponse
 */
export declare class ListFilesArtifactNamesAndUuidsResponse extends Message<ListFilesArtifactNamesAndUuidsResponse> {
  /**
   * @generated from field: repeated api_container_api.FilesArtifactNameAndUuid file_names_and_uuids = 1;
   */
  fileNamesAndUuids: FilesArtifactNameAndUuid[];

  constructor(data?: PartialMessage<ListFilesArtifactNamesAndUuidsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ListFilesArtifactNamesAndUuidsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFilesArtifactNamesAndUuidsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFilesArtifactNamesAndUuidsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFilesArtifactNamesAndUuidsResponse;

  static equals(a: ListFilesArtifactNamesAndUuidsResponse | PlainMessage<ListFilesArtifactNamesAndUuidsResponse> | undefined, b: ListFilesArtifactNamesAndUuidsResponse | PlainMessage<ListFilesArtifactNamesAndUuidsResponse> | undefined): boolean;
}

/**
 * @generated from message api_container_api.InspectFilesArtifactContentsRequest
 */
export declare class InspectFilesArtifactContentsRequest extends Message<InspectFilesArtifactContentsRequest> {
  /**
   * @generated from field: api_container_api.FilesArtifactNameAndUuid file_names_and_uuid = 1;
   */
  fileNamesAndUuid?: FilesArtifactNameAndUuid;

  constructor(data?: PartialMessage<InspectFilesArtifactContentsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.InspectFilesArtifactContentsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectFilesArtifactContentsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsRequest;

  static equals(a: InspectFilesArtifactContentsRequest | PlainMessage<InspectFilesArtifactContentsRequest> | undefined, b: InspectFilesArtifactContentsRequest | PlainMessage<InspectFilesArtifactContentsRequest> | undefined): boolean;
}

/**
 * @generated from message api_container_api.InspectFilesArtifactContentsResponse
 */
export declare class InspectFilesArtifactContentsResponse extends Message<InspectFilesArtifactContentsResponse> {
  /**
   * @generated from field: repeated api_container_api.FileArtifactContentsFileDescription file_descriptions = 1;
   */
  fileDescriptions: FileArtifactContentsFileDescription[];

  constructor(data?: PartialMessage<InspectFilesArtifactContentsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.InspectFilesArtifactContentsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectFilesArtifactContentsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectFilesArtifactContentsResponse;

  static equals(a: InspectFilesArtifactContentsResponse | PlainMessage<InspectFilesArtifactContentsResponse> | undefined, b: InspectFilesArtifactContentsResponse | PlainMessage<InspectFilesArtifactContentsResponse> | undefined): boolean;
}

/**
 * @generated from message api_container_api.FileArtifactContentsFileDescription
 */
export declare class FileArtifactContentsFileDescription extends Message<FileArtifactContentsFileDescription> {
  /**
   * Path relative to the file artifact
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Size of the file, in bytes
   *
   * @generated from field: uint64 size = 2;
   */
  size: bigint;

  /**
   * A bit of text content, if the file allows (similar to UNIX's 'head')
   *
   * @generated from field: optional string text_preview = 3;
   */
  textPreview?: string;

  constructor(data?: PartialMessage<FileArtifactContentsFileDescription>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.FileArtifactContentsFileDescription";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileArtifactContentsFileDescription;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileArtifactContentsFileDescription;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileArtifactContentsFileDescription;

  static equals(a: FileArtifactContentsFileDescription | PlainMessage<FileArtifactContentsFileDescription> | undefined, b: FileArtifactContentsFileDescription | PlainMessage<FileArtifactContentsFileDescription> | undefined): boolean;
}

/**
 * @generated from message api_container_api.ConnectServicesArgs
 */
export declare class ConnectServicesArgs extends Message<ConnectServicesArgs> {
  /**
   * @generated from field: api_container_api.Connect connect = 1;
   */
  connect: Connect;

  constructor(data?: PartialMessage<ConnectServicesArgs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ConnectServicesArgs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectServicesArgs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectServicesArgs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectServicesArgs;

  static equals(a: ConnectServicesArgs | PlainMessage<ConnectServicesArgs> | undefined, b: ConnectServicesArgs | PlainMessage<ConnectServicesArgs> | undefined): boolean;
}

/**
 * @generated from message api_container_api.ConnectServicesResponse
 */
export declare class ConnectServicesResponse extends Message<ConnectServicesResponse> {
  constructor(data?: PartialMessage<ConnectServicesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.ConnectServicesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectServicesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectServicesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectServicesResponse;

  static equals(a: ConnectServicesResponse | PlainMessage<ConnectServicesResponse> | undefined, b: ConnectServicesResponse | PlainMessage<ConnectServicesResponse> | undefined): boolean;
}

/**
 * @generated from message api_container_api.GetStarlarkRunResponse
 */
export declare class GetStarlarkRunResponse extends Message<GetStarlarkRunResponse> {
  /**
   * @generated from field: string package_id = 1;
   */
  packageId: string;

  /**
   * @generated from field: string serialized_script = 2;
   */
  serializedScript: string;

  /**
   * @generated from field: string serialized_params = 3;
   */
  serializedParams: string;

  /**
   * @generated from field: int32 parallelism = 4;
   */
  parallelism: number;

  /**
   * @generated from field: string relative_path_to_main_file = 5;
   */
  relativePathToMainFile: string;

  /**
   * @generated from field: string main_function_name = 6;
   */
  mainFunctionName: string;

  /**
   * @generated from field: repeated api_container_api.KurtosisFeatureFlag experimental_features = 7;
   */
  experimentalFeatures: KurtosisFeatureFlag[];

  /**
   * @generated from field: api_container_api.RestartPolicy restart_policy = 8;
   */
  restartPolicy: RestartPolicy;

  constructor(data?: PartialMessage<GetStarlarkRunResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api_container_api.GetStarlarkRunResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStarlarkRunResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStarlarkRunResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStarlarkRunResponse;

  static equals(a: GetStarlarkRunResponse | PlainMessage<GetStarlarkRunResponse> | undefined, b: GetStarlarkRunResponse | PlainMessage<GetStarlarkRunResponse> | undefined): boolean;
}

