// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: engine_service.proto

package kurtosis_engine_rpc_api_bindingsconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	kurtosis_engine_rpc_api_bindings "github.com/kurtosis-tech/kurtosis/api/golang/engine/kurtosis_engine_rpc_api_bindings"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion0_1_0

const (
	// EngineServiceName is the fully-qualified name of the EngineService service.
	EngineServiceName = "engine_api.EngineService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// EngineServiceGetEngineInfoProcedure is the fully-qualified name of the EngineService's
	// GetEngineInfo RPC.
	EngineServiceGetEngineInfoProcedure = "/engine_api.EngineService/GetEngineInfo"
	// EngineServiceCreateEnclaveProcedure is the fully-qualified name of the EngineService's
	// CreateEnclave RPC.
	EngineServiceCreateEnclaveProcedure = "/engine_api.EngineService/CreateEnclave"
	// EngineServiceGetEnclavesProcedure is the fully-qualified name of the EngineService's GetEnclaves
	// RPC.
	EngineServiceGetEnclavesProcedure = "/engine_api.EngineService/GetEnclaves"
	// EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure is the fully-qualified name of
	// the EngineService's GetExistingAndHistoricalEnclaveIdentifiers RPC.
	EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure = "/engine_api.EngineService/GetExistingAndHistoricalEnclaveIdentifiers"
	// EngineServiceStopEnclaveProcedure is the fully-qualified name of the EngineService's StopEnclave
	// RPC.
	EngineServiceStopEnclaveProcedure = "/engine_api.EngineService/StopEnclave"
	// EngineServiceDestroyEnclaveProcedure is the fully-qualified name of the EngineService's
	// DestroyEnclave RPC.
	EngineServiceDestroyEnclaveProcedure = "/engine_api.EngineService/DestroyEnclave"
	// EngineServiceCleanProcedure is the fully-qualified name of the EngineService's Clean RPC.
	EngineServiceCleanProcedure = "/engine_api.EngineService/Clean"
	// EngineServiceGetServiceLogsProcedure is the fully-qualified name of the EngineService's
	// GetServiceLogs RPC.
	EngineServiceGetServiceLogsProcedure = "/engine_api.EngineService/GetServiceLogs"
)

// EngineServiceClient is a client for the engine_api.EngineService service.
type EngineServiceClient interface {
	// Endpoint for getting information about the engine, which is also what we use to verify that the engine has become available
	GetEngineInfo(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEngineInfoResponse], error)
	// ==============================================================================================
	//
	//	Enclave Management
	//
	// ==============================================================================================
	// Creates a new Kurtosis Enclave
	CreateEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.CreateEnclaveArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CreateEnclaveResponse], error)
	// Returns information about the existing enclaves
	GetEnclaves(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEnclavesResponse], error)
	// Returns information about all existing & historical enclaves
	GetExistingAndHistoricalEnclaveIdentifiers(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetExistingAndHistoricalEnclaveIdentifiersResponse], error)
	// Stops all containers in an enclave
	StopEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.StopEnclaveArgs]) (*connect.Response[emptypb.Empty], error)
	// Destroys an enclave, removing all artifacts associated with it
	DestroyEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.DestroyEnclaveArgs]) (*connect.Response[emptypb.Empty], error)
	// Gets rid of old enclaves
	Clean(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.CleanArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CleanResponse], error)
	// Get service logs
	GetServiceLogs(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.GetServiceLogsArgs]) (*connect.ServerStreamForClient[kurtosis_engine_rpc_api_bindings.GetServiceLogsResponse], error)
}

// NewEngineServiceClient constructs a client for the engine_api.EngineService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewEngineServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) EngineServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &engineServiceClient{
		getEngineInfo: connect.NewClient[emptypb.Empty, kurtosis_engine_rpc_api_bindings.GetEngineInfoResponse](
			httpClient,
			baseURL+EngineServiceGetEngineInfoProcedure,
			opts...,
		),
		createEnclave: connect.NewClient[kurtosis_engine_rpc_api_bindings.CreateEnclaveArgs, kurtosis_engine_rpc_api_bindings.CreateEnclaveResponse](
			httpClient,
			baseURL+EngineServiceCreateEnclaveProcedure,
			opts...,
		),
		getEnclaves: connect.NewClient[emptypb.Empty, kurtosis_engine_rpc_api_bindings.GetEnclavesResponse](
			httpClient,
			baseURL+EngineServiceGetEnclavesProcedure,
			opts...,
		),
		getExistingAndHistoricalEnclaveIdentifiers: connect.NewClient[emptypb.Empty, kurtosis_engine_rpc_api_bindings.GetExistingAndHistoricalEnclaveIdentifiersResponse](
			httpClient,
			baseURL+EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure,
			opts...,
		),
		stopEnclave: connect.NewClient[kurtosis_engine_rpc_api_bindings.StopEnclaveArgs, emptypb.Empty](
			httpClient,
			baseURL+EngineServiceStopEnclaveProcedure,
			opts...,
		),
		destroyEnclave: connect.NewClient[kurtosis_engine_rpc_api_bindings.DestroyEnclaveArgs, emptypb.Empty](
			httpClient,
			baseURL+EngineServiceDestroyEnclaveProcedure,
			opts...,
		),
		clean: connect.NewClient[kurtosis_engine_rpc_api_bindings.CleanArgs, kurtosis_engine_rpc_api_bindings.CleanResponse](
			httpClient,
			baseURL+EngineServiceCleanProcedure,
			opts...,
		),
		getServiceLogs: connect.NewClient[kurtosis_engine_rpc_api_bindings.GetServiceLogsArgs, kurtosis_engine_rpc_api_bindings.GetServiceLogsResponse](
			httpClient,
			baseURL+EngineServiceGetServiceLogsProcedure,
			opts...,
		),
	}
}

// engineServiceClient implements EngineServiceClient.
type engineServiceClient struct {
	getEngineInfo                              *connect.Client[emptypb.Empty, kurtosis_engine_rpc_api_bindings.GetEngineInfoResponse]
	createEnclave                              *connect.Client[kurtosis_engine_rpc_api_bindings.CreateEnclaveArgs, kurtosis_engine_rpc_api_bindings.CreateEnclaveResponse]
	getEnclaves                                *connect.Client[emptypb.Empty, kurtosis_engine_rpc_api_bindings.GetEnclavesResponse]
	getExistingAndHistoricalEnclaveIdentifiers *connect.Client[emptypb.Empty, kurtosis_engine_rpc_api_bindings.GetExistingAndHistoricalEnclaveIdentifiersResponse]
	stopEnclave                                *connect.Client[kurtosis_engine_rpc_api_bindings.StopEnclaveArgs, emptypb.Empty]
	destroyEnclave                             *connect.Client[kurtosis_engine_rpc_api_bindings.DestroyEnclaveArgs, emptypb.Empty]
	clean                                      *connect.Client[kurtosis_engine_rpc_api_bindings.CleanArgs, kurtosis_engine_rpc_api_bindings.CleanResponse]
	getServiceLogs                             *connect.Client[kurtosis_engine_rpc_api_bindings.GetServiceLogsArgs, kurtosis_engine_rpc_api_bindings.GetServiceLogsResponse]
}

// GetEngineInfo calls engine_api.EngineService.GetEngineInfo.
func (c *engineServiceClient) GetEngineInfo(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEngineInfoResponse], error) {
	return c.getEngineInfo.CallUnary(ctx, req)
}

// CreateEnclave calls engine_api.EngineService.CreateEnclave.
func (c *engineServiceClient) CreateEnclave(ctx context.Context, req *connect.Request[kurtosis_engine_rpc_api_bindings.CreateEnclaveArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CreateEnclaveResponse], error) {
	return c.createEnclave.CallUnary(ctx, req)
}

// GetEnclaves calls engine_api.EngineService.GetEnclaves.
func (c *engineServiceClient) GetEnclaves(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEnclavesResponse], error) {
	return c.getEnclaves.CallUnary(ctx, req)
}

// GetExistingAndHistoricalEnclaveIdentifiers calls
// engine_api.EngineService.GetExistingAndHistoricalEnclaveIdentifiers.
func (c *engineServiceClient) GetExistingAndHistoricalEnclaveIdentifiers(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetExistingAndHistoricalEnclaveIdentifiersResponse], error) {
	return c.getExistingAndHistoricalEnclaveIdentifiers.CallUnary(ctx, req)
}

// StopEnclave calls engine_api.EngineService.StopEnclave.
func (c *engineServiceClient) StopEnclave(ctx context.Context, req *connect.Request[kurtosis_engine_rpc_api_bindings.StopEnclaveArgs]) (*connect.Response[emptypb.Empty], error) {
	return c.stopEnclave.CallUnary(ctx, req)
}

// DestroyEnclave calls engine_api.EngineService.DestroyEnclave.
func (c *engineServiceClient) DestroyEnclave(ctx context.Context, req *connect.Request[kurtosis_engine_rpc_api_bindings.DestroyEnclaveArgs]) (*connect.Response[emptypb.Empty], error) {
	return c.destroyEnclave.CallUnary(ctx, req)
}

// Clean calls engine_api.EngineService.Clean.
func (c *engineServiceClient) Clean(ctx context.Context, req *connect.Request[kurtosis_engine_rpc_api_bindings.CleanArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CleanResponse], error) {
	return c.clean.CallUnary(ctx, req)
}

// GetServiceLogs calls engine_api.EngineService.GetServiceLogs.
func (c *engineServiceClient) GetServiceLogs(ctx context.Context, req *connect.Request[kurtosis_engine_rpc_api_bindings.GetServiceLogsArgs]) (*connect.ServerStreamForClient[kurtosis_engine_rpc_api_bindings.GetServiceLogsResponse], error) {
	return c.getServiceLogs.CallServerStream(ctx, req)
}

// EngineServiceHandler is an implementation of the engine_api.EngineService service.
type EngineServiceHandler interface {
	// Endpoint for getting information about the engine, which is also what we use to verify that the engine has become available
	GetEngineInfo(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEngineInfoResponse], error)
	// ==============================================================================================
	//
	//	Enclave Management
	//
	// ==============================================================================================
	// Creates a new Kurtosis Enclave
	CreateEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.CreateEnclaveArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CreateEnclaveResponse], error)
	// Returns information about the existing enclaves
	GetEnclaves(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEnclavesResponse], error)
	// Returns information about all existing & historical enclaves
	GetExistingAndHistoricalEnclaveIdentifiers(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetExistingAndHistoricalEnclaveIdentifiersResponse], error)
	// Stops all containers in an enclave
	StopEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.StopEnclaveArgs]) (*connect.Response[emptypb.Empty], error)
	// Destroys an enclave, removing all artifacts associated with it
	DestroyEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.DestroyEnclaveArgs]) (*connect.Response[emptypb.Empty], error)
	// Gets rid of old enclaves
	Clean(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.CleanArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CleanResponse], error)
	// Get service logs
	GetServiceLogs(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.GetServiceLogsArgs], *connect.ServerStream[kurtosis_engine_rpc_api_bindings.GetServiceLogsResponse]) error
}

// NewEngineServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewEngineServiceHandler(svc EngineServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	engineServiceGetEngineInfoHandler := connect.NewUnaryHandler(
		EngineServiceGetEngineInfoProcedure,
		svc.GetEngineInfo,
		opts...,
	)
	engineServiceCreateEnclaveHandler := connect.NewUnaryHandler(
		EngineServiceCreateEnclaveProcedure,
		svc.CreateEnclave,
		opts...,
	)
	engineServiceGetEnclavesHandler := connect.NewUnaryHandler(
		EngineServiceGetEnclavesProcedure,
		svc.GetEnclaves,
		opts...,
	)
	engineServiceGetExistingAndHistoricalEnclaveIdentifiersHandler := connect.NewUnaryHandler(
		EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure,
		svc.GetExistingAndHistoricalEnclaveIdentifiers,
		opts...,
	)
	engineServiceStopEnclaveHandler := connect.NewUnaryHandler(
		EngineServiceStopEnclaveProcedure,
		svc.StopEnclave,
		opts...,
	)
	engineServiceDestroyEnclaveHandler := connect.NewUnaryHandler(
		EngineServiceDestroyEnclaveProcedure,
		svc.DestroyEnclave,
		opts...,
	)
	engineServiceCleanHandler := connect.NewUnaryHandler(
		EngineServiceCleanProcedure,
		svc.Clean,
		opts...,
	)
	engineServiceGetServiceLogsHandler := connect.NewServerStreamHandler(
		EngineServiceGetServiceLogsProcedure,
		svc.GetServiceLogs,
		opts...,
	)
	return "/engine_api.EngineService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case EngineServiceGetEngineInfoProcedure:
			engineServiceGetEngineInfoHandler.ServeHTTP(w, r)
		case EngineServiceCreateEnclaveProcedure:
			engineServiceCreateEnclaveHandler.ServeHTTP(w, r)
		case EngineServiceGetEnclavesProcedure:
			engineServiceGetEnclavesHandler.ServeHTTP(w, r)
		case EngineServiceGetExistingAndHistoricalEnclaveIdentifiersProcedure:
			engineServiceGetExistingAndHistoricalEnclaveIdentifiersHandler.ServeHTTP(w, r)
		case EngineServiceStopEnclaveProcedure:
			engineServiceStopEnclaveHandler.ServeHTTP(w, r)
		case EngineServiceDestroyEnclaveProcedure:
			engineServiceDestroyEnclaveHandler.ServeHTTP(w, r)
		case EngineServiceCleanProcedure:
			engineServiceCleanHandler.ServeHTTP(w, r)
		case EngineServiceGetServiceLogsProcedure:
			engineServiceGetServiceLogsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedEngineServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedEngineServiceHandler struct{}

func (UnimplementedEngineServiceHandler) GetEngineInfo(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEngineInfoResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.GetEngineInfo is not implemented"))
}

func (UnimplementedEngineServiceHandler) CreateEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.CreateEnclaveArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CreateEnclaveResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.CreateEnclave is not implemented"))
}

func (UnimplementedEngineServiceHandler) GetEnclaves(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetEnclavesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.GetEnclaves is not implemented"))
}

func (UnimplementedEngineServiceHandler) GetExistingAndHistoricalEnclaveIdentifiers(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[kurtosis_engine_rpc_api_bindings.GetExistingAndHistoricalEnclaveIdentifiersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.GetExistingAndHistoricalEnclaveIdentifiers is not implemented"))
}

func (UnimplementedEngineServiceHandler) StopEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.StopEnclaveArgs]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.StopEnclave is not implemented"))
}

func (UnimplementedEngineServiceHandler) DestroyEnclave(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.DestroyEnclaveArgs]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.DestroyEnclave is not implemented"))
}

func (UnimplementedEngineServiceHandler) Clean(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.CleanArgs]) (*connect.Response[kurtosis_engine_rpc_api_bindings.CleanResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.Clean is not implemented"))
}

func (UnimplementedEngineServiceHandler) GetServiceLogs(context.Context, *connect.Request[kurtosis_engine_rpc_api_bindings.GetServiceLogsArgs], *connect.ServerStream[kurtosis_engine_rpc_api_bindings.GetServiceLogsResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("engine_api.EngineService.GetServiceLogs is not implemented"))
}
