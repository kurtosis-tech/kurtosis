// Code generated by mockery v2.22.1. DO NOT EDIT.

package backend_interface

import (
	api_container "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/api_container"
	compute_resources "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/compute_resources"

	context "context"

	enclave "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/enclave"

	engine "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/engine"

	exec_result "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/exec_result"

	image_download_mode "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/image_download_mode"

	io "io"

	logs_aggregator "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/logs_aggregator"

	logs_collector "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/logs_collector"

	mock "github.com/stretchr/testify/mock"

	service "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/service"

	time "time"
)

// MockKurtosisBackend is an autogenerated mock type for the KurtosisBackend type
type MockKurtosisBackend struct {
	mock.Mock
}

type MockKurtosisBackend_Expecter struct {
	mock *mock.Mock
}

func (_m *MockKurtosisBackend) EXPECT() *MockKurtosisBackend_Expecter {
	return &MockKurtosisBackend_Expecter{mock: &_m.Mock}
}

// CopyFilesFromUserService provides a mock function with given fields: ctx, enclaveUuid, serviceUuid, srcPathOnService, output
func (_m *MockKurtosisBackend) CopyFilesFromUserService(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID, srcPathOnService string, output io.Writer) error {
	ret := _m.Called(ctx, enclaveUuid, serviceUuid, srcPathOnService, output)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, string, io.Writer) error); ok {
		r0 = rf(ctx, enclaveUuid, serviceUuid, srcPathOnService, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_CopyFilesFromUserService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFilesFromUserService'
type MockKurtosisBackend_CopyFilesFromUserService_Call struct {
	*mock.Call
}

// CopyFilesFromUserService is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - serviceUuid service.ServiceUUID
//   - srcPathOnService string
//   - output io.Writer
func (_e *MockKurtosisBackend_Expecter) CopyFilesFromUserService(ctx interface{}, enclaveUuid interface{}, serviceUuid interface{}, srcPathOnService interface{}, output interface{}) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	return &MockKurtosisBackend_CopyFilesFromUserService_Call{Call: _e.mock.On("CopyFilesFromUserService", ctx, enclaveUuid, serviceUuid, srcPathOnService, output)}
}

func (_c *MockKurtosisBackend_CopyFilesFromUserService_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID, srcPathOnService string, output io.Writer)) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(service.ServiceUUID), args[3].(string), args[4].(io.Writer))
	})
	return _c
}

func (_c *MockKurtosisBackend_CopyFilesFromUserService_Call) Return(_a0 error) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_CopyFilesFromUserService_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, string, io.Writer) error) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAPIContainer provides a mock function with given fields: ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars
func (_m *MockKurtosisBackend) CreateAPIContainer(ctx context.Context, image string, enclaveUuid enclave.EnclaveUUID, grpcPortNum uint16, enclaveDataVolumeDirpath string, ownIpAddressEnvVar string, customEnvVars map[string]string) (*api_container.APIContainer, error) {
	ret := _m.Called(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)

	var r0 *api_container.APIContainer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) (*api_container.APIContainer, error)); ok {
		return rf(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) *api_container.APIContainer); ok {
		r0 = rf(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api_container.APIContainer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) error); ok {
		r1 = rf(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateAPIContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAPIContainer'
type MockKurtosisBackend_CreateAPIContainer_Call struct {
	*mock.Call
}

// CreateAPIContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
//   - enclaveUuid enclave.EnclaveUUID
//   - grpcPortNum uint16
//   - enclaveDataVolumeDirpath string
//   - ownIpAddressEnvVar string
//   - customEnvVars map[string]string
func (_e *MockKurtosisBackend_Expecter) CreateAPIContainer(ctx interface{}, image interface{}, enclaveUuid interface{}, grpcPortNum interface{}, enclaveDataVolumeDirpath interface{}, ownIpAddressEnvVar interface{}, customEnvVars interface{}) *MockKurtosisBackend_CreateAPIContainer_Call {
	return &MockKurtosisBackend_CreateAPIContainer_Call{Call: _e.mock.On("CreateAPIContainer", ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)}
}

func (_c *MockKurtosisBackend_CreateAPIContainer_Call) Run(run func(ctx context.Context, image string, enclaveUuid enclave.EnclaveUUID, grpcPortNum uint16, enclaveDataVolumeDirpath string, ownIpAddressEnvVar string, customEnvVars map[string]string)) *MockKurtosisBackend_CreateAPIContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(enclave.EnclaveUUID), args[3].(uint16), args[4].(string), args[5].(string), args[6].(map[string]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateAPIContainer_Call) Return(_a0 *api_container.APIContainer, _a1 error) *MockKurtosisBackend_CreateAPIContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_CreateAPIContainer_Call) RunAndReturn(run func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) (*api_container.APIContainer, error)) *MockKurtosisBackend_CreateAPIContainer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEnclave provides a mock function with given fields: ctx, enclaveUuid, enclaveName
func (_m *MockKurtosisBackend) CreateEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, enclaveName string) (*enclave.Enclave, error) {
	ret := _m.Called(ctx, enclaveUuid, enclaveName)

	var r0 *enclave.Enclave
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string) (*enclave.Enclave, error)); ok {
		return rf(ctx, enclaveUuid, enclaveName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string) *enclave.Enclave); ok {
		r0 = rf(ctx, enclaveUuid, enclaveName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*enclave.Enclave)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, string) error); ok {
		r1 = rf(ctx, enclaveUuid, enclaveName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEnclave'
type MockKurtosisBackend_CreateEnclave_Call struct {
	*mock.Call
}

// CreateEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - enclaveName string
func (_e *MockKurtosisBackend_Expecter) CreateEnclave(ctx interface{}, enclaveUuid interface{}, enclaveName interface{}) *MockKurtosisBackend_CreateEnclave_Call {
	return &MockKurtosisBackend_CreateEnclave_Call{Call: _e.mock.On("CreateEnclave", ctx, enclaveUuid, enclaveName)}
}

func (_c *MockKurtosisBackend_CreateEnclave_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, enclaveName string)) *MockKurtosisBackend_CreateEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(string))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateEnclave_Call) Return(_a0 *enclave.Enclave, _a1 error) *MockKurtosisBackend_CreateEnclave_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_CreateEnclave_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, string) (*enclave.Enclave, error)) *MockKurtosisBackend_CreateEnclave_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEngine provides a mock function with given fields: ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars
func (_m *MockKurtosisBackend) CreateEngine(ctx context.Context, imageOrgAndRepo string, imageVersionTag string, grpcPortNum uint16, envVars map[string]string) (*engine.Engine, error) {
	ret := _m.Called(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)

	var r0 *engine.Engine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint16, map[string]string) (*engine.Engine, error)); ok {
		return rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint16, map[string]string) *engine.Engine); ok {
		r0 = rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*engine.Engine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint16, map[string]string) error); ok {
		r1 = rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateEngine_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEngine'
type MockKurtosisBackend_CreateEngine_Call struct {
	*mock.Call
}

// CreateEngine is a helper method to define mock.On call
//   - ctx context.Context
//   - imageOrgAndRepo string
//   - imageVersionTag string
//   - grpcPortNum uint16
//   - envVars map[string]string
func (_e *MockKurtosisBackend_Expecter) CreateEngine(ctx interface{}, imageOrgAndRepo interface{}, imageVersionTag interface{}, grpcPortNum interface{}, envVars interface{}) *MockKurtosisBackend_CreateEngine_Call {
	return &MockKurtosisBackend_CreateEngine_Call{Call: _e.mock.On("CreateEngine", ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)}
}

func (_c *MockKurtosisBackend_CreateEngine_Call) Run(run func(ctx context.Context, imageOrgAndRepo string, imageVersionTag string, grpcPortNum uint16, envVars map[string]string)) *MockKurtosisBackend_CreateEngine_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint16), args[4].(map[string]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateEngine_Call) Return(_a0 *engine.Engine, _a1 error) *MockKurtosisBackend_CreateEngine_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_CreateEngine_Call) RunAndReturn(run func(context.Context, string, string, uint16, map[string]string) (*engine.Engine, error)) *MockKurtosisBackend_CreateEngine_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLogsAggregator provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) CreateLogsAggregator(ctx context.Context) (*logs_aggregator.LogsAggregator, error) {
	ret := _m.Called(ctx)

	var r0 *logs_aggregator.LogsAggregator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*logs_aggregator.LogsAggregator, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *logs_aggregator.LogsAggregator); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_aggregator.LogsAggregator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateLogsAggregator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLogsAggregator'
type MockKurtosisBackend_CreateLogsAggregator_Call struct {
	*mock.Call
}

// CreateLogsAggregator is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) CreateLogsAggregator(ctx interface{}) *MockKurtosisBackend_CreateLogsAggregator_Call {
	return &MockKurtosisBackend_CreateLogsAggregator_Call{Call: _e.mock.On("CreateLogsAggregator", ctx)}
}

func (_c *MockKurtosisBackend_CreateLogsAggregator_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_CreateLogsAggregator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateLogsAggregator_Call) Return(_a0 *logs_aggregator.LogsAggregator, _a1 error) *MockKurtosisBackend_CreateLogsAggregator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_CreateLogsAggregator_Call) RunAndReturn(run func(context.Context) (*logs_aggregator.LogsAggregator, error)) *MockKurtosisBackend_CreateLogsAggregator_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLogsCollectorForEnclave provides a mock function with given fields: ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber
func (_m *MockKurtosisBackend) CreateLogsCollectorForEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, logsCollectorHttpPortNumber uint16, logsCollectorTcpPortNumber uint16) (*logs_collector.LogsCollector, error) {
	ret := _m.Called(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)

	var r0 *logs_collector.LogsCollector
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, uint16, uint16) (*logs_collector.LogsCollector, error)); ok {
		return rf(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, uint16, uint16) *logs_collector.LogsCollector); ok {
		r0 = rf(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_collector.LogsCollector)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, uint16, uint16) error); ok {
		r1 = rf(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateLogsCollectorForEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLogsCollectorForEnclave'
type MockKurtosisBackend_CreateLogsCollectorForEnclave_Call struct {
	*mock.Call
}

// CreateLogsCollectorForEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - logsCollectorHttpPortNumber uint16
//   - logsCollectorTcpPortNumber uint16
func (_e *MockKurtosisBackend_Expecter) CreateLogsCollectorForEnclave(ctx interface{}, enclaveUuid interface{}, logsCollectorHttpPortNumber interface{}, logsCollectorTcpPortNumber interface{}) *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call {
	return &MockKurtosisBackend_CreateLogsCollectorForEnclave_Call{Call: _e.mock.On("CreateLogsCollectorForEnclave", ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)}
}

func (_c *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, logsCollectorHttpPortNumber uint16, logsCollectorTcpPortNumber uint16)) *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(uint16), args[3].(uint16))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call) Return(_a0 *logs_collector.LogsCollector, _a1 error) *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, uint16, uint16) (*logs_collector.LogsCollector, error)) *MockKurtosisBackend_CreateLogsCollectorForEnclave_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyAPIContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyAPIContainers'
type MockKurtosisBackend_DestroyAPIContainers_Call struct {
	*mock.Call
}

// DestroyAPIContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *api_container.APIContainerFilters
func (_e *MockKurtosisBackend_Expecter) DestroyAPIContainers(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyAPIContainers_Call {
	return &MockKurtosisBackend_DestroyAPIContainers_Call{Call: _e.mock.On("DestroyAPIContainers", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyAPIContainers_Call) Run(run func(ctx context.Context, filters *api_container.APIContainerFilters)) *MockKurtosisBackend_DestroyAPIContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api_container.APIContainerFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyAPIContainers_Call) Return(successfulApiContainerIds map[enclave.EnclaveUUID]bool, erroredApiContainerIds map[enclave.EnclaveUUID]error, resultErr error) *MockKurtosisBackend_DestroyAPIContainers_Call {
	_c.Call.Return(successfulApiContainerIds, erroredApiContainerIds, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_DestroyAPIContainers_Call) RunAndReturn(run func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)) *MockKurtosisBackend_DestroyAPIContainers_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyEnclaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyEnclaves'
type MockKurtosisBackend_DestroyEnclaves_Call struct {
	*mock.Call
}

// DestroyEnclaves is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *enclave.EnclaveFilters
func (_e *MockKurtosisBackend_Expecter) DestroyEnclaves(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyEnclaves_Call {
	return &MockKurtosisBackend_DestroyEnclaves_Call{Call: _e.mock.On("DestroyEnclaves", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyEnclaves_Call) Run(run func(ctx context.Context, filters *enclave.EnclaveFilters)) *MockKurtosisBackend_DestroyEnclaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*enclave.EnclaveFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyEnclaves_Call) Return(successfulEnclaveIds map[enclave.EnclaveUUID]bool, erroredEnclaveIds map[enclave.EnclaveUUID]error, resultErr error) *MockKurtosisBackend_DestroyEnclaves_Call {
	_c.Call.Return(successfulEnclaveIds, erroredEnclaveIds, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_DestroyEnclaves_Call) RunAndReturn(run func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)) *MockKurtosisBackend_DestroyEnclaves_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]bool
	var r1 map[engine.EngineGUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[engine.EngineGUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *engine.EngineFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyEngines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyEngines'
type MockKurtosisBackend_DestroyEngines_Call struct {
	*mock.Call
}

// DestroyEngines is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *engine.EngineFilters
func (_e *MockKurtosisBackend_Expecter) DestroyEngines(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyEngines_Call {
	return &MockKurtosisBackend_DestroyEngines_Call{Call: _e.mock.On("DestroyEngines", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyEngines_Call) Run(run func(ctx context.Context, filters *engine.EngineFilters)) *MockKurtosisBackend_DestroyEngines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*engine.EngineFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyEngines_Call) Return(successfulEngineGuids map[engine.EngineGUID]bool, erroredEngineGuids map[engine.EngineGUID]error, resultErr error) *MockKurtosisBackend_DestroyEngines_Call {
	_c.Call.Return(successfulEngineGuids, erroredEngineGuids, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_DestroyEngines_Call) RunAndReturn(run func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error)) *MockKurtosisBackend_DestroyEngines_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyLogsAggregator provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) DestroyLogsAggregator(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DestroyLogsAggregator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyLogsAggregator'
type MockKurtosisBackend_DestroyLogsAggregator_Call struct {
	*mock.Call
}

// DestroyLogsAggregator is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) DestroyLogsAggregator(ctx interface{}) *MockKurtosisBackend_DestroyLogsAggregator_Call {
	return &MockKurtosisBackend_DestroyLogsAggregator_Call{Call: _e.mock.On("DestroyLogsAggregator", ctx)}
}

func (_c *MockKurtosisBackend_DestroyLogsAggregator_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_DestroyLogsAggregator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyLogsAggregator_Call) Return(_a0 error) *MockKurtosisBackend_DestroyLogsAggregator_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_DestroyLogsAggregator_Call) RunAndReturn(run func(context.Context) error) *MockKurtosisBackend_DestroyLogsAggregator_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyLogsCollectorForEnclave provides a mock function with given fields: ctx, enclaveUuid
func (_m *MockKurtosisBackend) DestroyLogsCollectorForEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID) error {
	ret := _m.Called(ctx, enclaveUuid)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID) error); ok {
		r0 = rf(ctx, enclaveUuid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyLogsCollectorForEnclave'
type MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call struct {
	*mock.Call
}

// DestroyLogsCollectorForEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
func (_e *MockKurtosisBackend_Expecter) DestroyLogsCollectorForEnclave(ctx interface{}, enclaveUuid interface{}) *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call {
	return &MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call{Call: _e.mock.On("DestroyLogsCollectorForEnclave", ctx, enclaveUuid)}
}

func (_c *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID)) *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call) Return(_a0 error) *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID) error) *MockKurtosisBackend_DestroyLogsCollectorForEnclave_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyUserServices provides a mock function with given fields: ctx, enclaveUuid, filters
func (_m *MockKurtosisBackend) DestroyUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, filters)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) error); ok {
		r2 = rf(ctx, enclaveUuid, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyUserServices'
type MockKurtosisBackend_DestroyUserServices_Call struct {
	*mock.Call
}

// DestroyUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - filters *service.ServiceFilters
func (_e *MockKurtosisBackend_Expecter) DestroyUserServices(ctx interface{}, enclaveUuid interface{}, filters interface{}) *MockKurtosisBackend_DestroyUserServices_Call {
	return &MockKurtosisBackend_DestroyUserServices_Call{Call: _e.mock.On("DestroyUserServices", ctx, enclaveUuid, filters)}
}

func (_c *MockKurtosisBackend_DestroyUserServices_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters)) *MockKurtosisBackend_DestroyUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(*service.ServiceFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyUserServices_Call) Return(successfulUserServiceUuids map[service.ServiceUUID]bool, erroredUserServiceUuids map[service.ServiceUUID]error, resultErr error) *MockKurtosisBackend_DestroyUserServices_Call {
	_c.Call.Return(successfulUserServiceUuids, erroredUserServiceUuids, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_DestroyUserServices_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_DestroyUserServices_Call {
	_c.Call.Return(run)
	return _c
}

// DumpEnclave provides a mock function with given fields: ctx, enclaveUuid, outputDirpath
func (_m *MockKurtosisBackend) DumpEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, outputDirpath string) error {
	ret := _m.Called(ctx, enclaveUuid, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string) error); ok {
		r0 = rf(ctx, enclaveUuid, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DumpEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpEnclave'
type MockKurtosisBackend_DumpEnclave_Call struct {
	*mock.Call
}

// DumpEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - outputDirpath string
func (_e *MockKurtosisBackend_Expecter) DumpEnclave(ctx interface{}, enclaveUuid interface{}, outputDirpath interface{}) *MockKurtosisBackend_DumpEnclave_Call {
	return &MockKurtosisBackend_DumpEnclave_Call{Call: _e.mock.On("DumpEnclave", ctx, enclaveUuid, outputDirpath)}
}

func (_c *MockKurtosisBackend_DumpEnclave_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, outputDirpath string)) *MockKurtosisBackend_DumpEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(string))
	})
	return _c
}

func (_c *MockKurtosisBackend_DumpEnclave_Call) Return(_a0 error) *MockKurtosisBackend_DumpEnclave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_DumpEnclave_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, string) error) *MockKurtosisBackend_DumpEnclave_Call {
	_c.Call.Return(run)
	return _c
}

// DumpKurtosis provides a mock function with given fields: ctx, outputDirpath
func (_m *MockKurtosisBackend) DumpKurtosis(ctx context.Context, outputDirpath string) error {
	ret := _m.Called(ctx, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DumpKurtosis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpKurtosis'
type MockKurtosisBackend_DumpKurtosis_Call struct {
	*mock.Call
}

// DumpKurtosis is a helper method to define mock.On call
//   - ctx context.Context
//   - outputDirpath string
func (_e *MockKurtosisBackend_Expecter) DumpKurtosis(ctx interface{}, outputDirpath interface{}) *MockKurtosisBackend_DumpKurtosis_Call {
	return &MockKurtosisBackend_DumpKurtosis_Call{Call: _e.mock.On("DumpKurtosis", ctx, outputDirpath)}
}

func (_c *MockKurtosisBackend_DumpKurtosis_Call) Run(run func(ctx context.Context, outputDirpath string)) *MockKurtosisBackend_DumpKurtosis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockKurtosisBackend_DumpKurtosis_Call) Return(_a0 error) *MockKurtosisBackend_DumpKurtosis_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_DumpKurtosis_Call) RunAndReturn(run func(context.Context, string) error) *MockKurtosisBackend_DumpKurtosis_Call {
	_c.Call.Return(run)
	return _c
}

// FetchImage provides a mock function with given fields: ctx, image, downloadMode
func (_m *MockKurtosisBackend) FetchImage(ctx context.Context, image string, downloadMode image_download_mode.ImageDownloadMode) (bool, string, error) {
	ret := _m.Called(ctx, image, downloadMode)

	var r0 bool
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, image_download_mode.ImageDownloadMode) (bool, string, error)); ok {
		return rf(ctx, image, downloadMode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, image_download_mode.ImageDownloadMode) bool); ok {
		r0 = rf(ctx, image, downloadMode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, image_download_mode.ImageDownloadMode) string); ok {
		r1 = rf(ctx, image, downloadMode)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, image_download_mode.ImageDownloadMode) error); ok {
		r2 = rf(ctx, image, downloadMode)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_FetchImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchImage'
type MockKurtosisBackend_FetchImage_Call struct {
	*mock.Call
}

// FetchImage is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
//   - downloadMode image_download_mode.ImageDownloadMode
func (_e *MockKurtosisBackend_Expecter) FetchImage(ctx interface{}, image interface{}, downloadMode interface{}) *MockKurtosisBackend_FetchImage_Call {
	return &MockKurtosisBackend_FetchImage_Call{Call: _e.mock.On("FetchImage", ctx, image, downloadMode)}
}

func (_c *MockKurtosisBackend_FetchImage_Call) Run(run func(ctx context.Context, image string, downloadMode image_download_mode.ImageDownloadMode)) *MockKurtosisBackend_FetchImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(image_download_mode.ImageDownloadMode))
	})
	return _c
}

func (_c *MockKurtosisBackend_FetchImage_Call) Return(_a0 bool, _a1 string, _a2 error) *MockKurtosisBackend_FetchImage_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockKurtosisBackend_FetchImage_Call) RunAndReturn(run func(context.Context, string, image_download_mode.ImageDownloadMode) (bool, string, error)) *MockKurtosisBackend_FetchImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]*api_container.APIContainer, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]*api_container.APIContainer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]*api_container.APIContainer, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]*api_container.APIContainer); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]*api_container.APIContainer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetAPIContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAPIContainers'
type MockKurtosisBackend_GetAPIContainers_Call struct {
	*mock.Call
}

// GetAPIContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *api_container.APIContainerFilters
func (_e *MockKurtosisBackend_Expecter) GetAPIContainers(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetAPIContainers_Call {
	return &MockKurtosisBackend_GetAPIContainers_Call{Call: _e.mock.On("GetAPIContainers", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetAPIContainers_Call) Run(run func(ctx context.Context, filters *api_container.APIContainerFilters)) *MockKurtosisBackend_GetAPIContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api_container.APIContainerFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetAPIContainers_Call) Return(_a0 map[enclave.EnclaveUUID]*api_container.APIContainer, _a1 error) *MockKurtosisBackend_GetAPIContainers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_GetAPIContainers_Call) RunAndReturn(run func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]*api_container.APIContainer, error)) *MockKurtosisBackend_GetAPIContainers_Call {
	_c.Call.Return(run)
	return _c
}

// GetAvailableCPUAndMemory provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) GetAvailableCPUAndMemory(ctx context.Context) (compute_resources.MemoryInMegaBytes, compute_resources.CpuMilliCores, bool, error) {
	ret := _m.Called(ctx)

	var r0 compute_resources.MemoryInMegaBytes
	var r1 compute_resources.CpuMilliCores
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context) (compute_resources.MemoryInMegaBytes, compute_resources.CpuMilliCores, bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) compute_resources.MemoryInMegaBytes); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(compute_resources.MemoryInMegaBytes)
	}

	if rf, ok := ret.Get(1).(func(context.Context) compute_resources.CpuMilliCores); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(compute_resources.CpuMilliCores)
	}

	if rf, ok := ret.Get(2).(func(context.Context) bool); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func(context.Context) error); ok {
		r3 = rf(ctx)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockKurtosisBackend_GetAvailableCPUAndMemory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAvailableCPUAndMemory'
type MockKurtosisBackend_GetAvailableCPUAndMemory_Call struct {
	*mock.Call
}

// GetAvailableCPUAndMemory is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) GetAvailableCPUAndMemory(ctx interface{}) *MockKurtosisBackend_GetAvailableCPUAndMemory_Call {
	return &MockKurtosisBackend_GetAvailableCPUAndMemory_Call{Call: _e.mock.On("GetAvailableCPUAndMemory", ctx)}
}

func (_c *MockKurtosisBackend_GetAvailableCPUAndMemory_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_GetAvailableCPUAndMemory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetAvailableCPUAndMemory_Call) Return(_a0 compute_resources.MemoryInMegaBytes, _a1 compute_resources.CpuMilliCores, _a2 bool, _a3 error) *MockKurtosisBackend_GetAvailableCPUAndMemory_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockKurtosisBackend_GetAvailableCPUAndMemory_Call) RunAndReturn(run func(context.Context) (compute_resources.MemoryInMegaBytes, compute_resources.CpuMilliCores, bool, error)) *MockKurtosisBackend_GetAvailableCPUAndMemory_Call {
	_c.Call.Return(run)
	return _c
}

// GetEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]*enclave.Enclave, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]*enclave.Enclave
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]*enclave.Enclave, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]*enclave.Enclave); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]*enclave.Enclave)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetEnclaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEnclaves'
type MockKurtosisBackend_GetEnclaves_Call struct {
	*mock.Call
}

// GetEnclaves is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *enclave.EnclaveFilters
func (_e *MockKurtosisBackend_Expecter) GetEnclaves(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetEnclaves_Call {
	return &MockKurtosisBackend_GetEnclaves_Call{Call: _e.mock.On("GetEnclaves", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetEnclaves_Call) Run(run func(ctx context.Context, filters *enclave.EnclaveFilters)) *MockKurtosisBackend_GetEnclaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*enclave.EnclaveFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetEnclaves_Call) Return(_a0 map[enclave.EnclaveUUID]*enclave.Enclave, _a1 error) *MockKurtosisBackend_GetEnclaves_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_GetEnclaves_Call) RunAndReturn(run func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]*enclave.Enclave, error)) *MockKurtosisBackend_GetEnclaves_Call {
	_c.Call.Return(run)
	return _c
}

// GetEngineLogs provides a mock function with given fields: ctx, outputDirpath
func (_m *MockKurtosisBackend) GetEngineLogs(ctx context.Context, outputDirpath string) error {
	ret := _m.Called(ctx, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_GetEngineLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEngineLogs'
type MockKurtosisBackend_GetEngineLogs_Call struct {
	*mock.Call
}

// GetEngineLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - outputDirpath string
func (_e *MockKurtosisBackend_Expecter) GetEngineLogs(ctx interface{}, outputDirpath interface{}) *MockKurtosisBackend_GetEngineLogs_Call {
	return &MockKurtosisBackend_GetEngineLogs_Call{Call: _e.mock.On("GetEngineLogs", ctx, outputDirpath)}
}

func (_c *MockKurtosisBackend_GetEngineLogs_Call) Run(run func(ctx context.Context, outputDirpath string)) *MockKurtosisBackend_GetEngineLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetEngineLogs_Call) Return(_a0 error) *MockKurtosisBackend_GetEngineLogs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_GetEngineLogs_Call) RunAndReturn(run func(context.Context, string) error) *MockKurtosisBackend_GetEngineLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]*engine.Engine, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]*engine.Engine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]*engine.Engine, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]*engine.Engine); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]*engine.Engine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetEngines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEngines'
type MockKurtosisBackend_GetEngines_Call struct {
	*mock.Call
}

// GetEngines is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *engine.EngineFilters
func (_e *MockKurtosisBackend_Expecter) GetEngines(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetEngines_Call {
	return &MockKurtosisBackend_GetEngines_Call{Call: _e.mock.On("GetEngines", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetEngines_Call) Run(run func(ctx context.Context, filters *engine.EngineFilters)) *MockKurtosisBackend_GetEngines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*engine.EngineFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetEngines_Call) Return(_a0 map[engine.EngineGUID]*engine.Engine, _a1 error) *MockKurtosisBackend_GetEngines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_GetEngines_Call) RunAndReturn(run func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]*engine.Engine, error)) *MockKurtosisBackend_GetEngines_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsAggregator provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) GetLogsAggregator(ctx context.Context) (*logs_aggregator.LogsAggregator, error) {
	ret := _m.Called(ctx)

	var r0 *logs_aggregator.LogsAggregator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*logs_aggregator.LogsAggregator, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *logs_aggregator.LogsAggregator); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_aggregator.LogsAggregator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetLogsAggregator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsAggregator'
type MockKurtosisBackend_GetLogsAggregator_Call struct {
	*mock.Call
}

// GetLogsAggregator is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) GetLogsAggregator(ctx interface{}) *MockKurtosisBackend_GetLogsAggregator_Call {
	return &MockKurtosisBackend_GetLogsAggregator_Call{Call: _e.mock.On("GetLogsAggregator", ctx)}
}

func (_c *MockKurtosisBackend_GetLogsAggregator_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_GetLogsAggregator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetLogsAggregator_Call) Return(_a0 *logs_aggregator.LogsAggregator, _a1 error) *MockKurtosisBackend_GetLogsAggregator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_GetLogsAggregator_Call) RunAndReturn(run func(context.Context) (*logs_aggregator.LogsAggregator, error)) *MockKurtosisBackend_GetLogsAggregator_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsCollectorForEnclave provides a mock function with given fields: ctx, enclaveUuid
func (_m *MockKurtosisBackend) GetLogsCollectorForEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID) (*logs_collector.LogsCollector, error) {
	ret := _m.Called(ctx, enclaveUuid)

	var r0 *logs_collector.LogsCollector
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID) (*logs_collector.LogsCollector, error)); ok {
		return rf(ctx, enclaveUuid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID) *logs_collector.LogsCollector); ok {
		r0 = rf(ctx, enclaveUuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_collector.LogsCollector)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID) error); ok {
		r1 = rf(ctx, enclaveUuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetLogsCollectorForEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsCollectorForEnclave'
type MockKurtosisBackend_GetLogsCollectorForEnclave_Call struct {
	*mock.Call
}

// GetLogsCollectorForEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
func (_e *MockKurtosisBackend_Expecter) GetLogsCollectorForEnclave(ctx interface{}, enclaveUuid interface{}) *MockKurtosisBackend_GetLogsCollectorForEnclave_Call {
	return &MockKurtosisBackend_GetLogsCollectorForEnclave_Call{Call: _e.mock.On("GetLogsCollectorForEnclave", ctx, enclaveUuid)}
}

func (_c *MockKurtosisBackend_GetLogsCollectorForEnclave_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID)) *MockKurtosisBackend_GetLogsCollectorForEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetLogsCollectorForEnclave_Call) Return(_a0 *logs_collector.LogsCollector, _a1 error) *MockKurtosisBackend_GetLogsCollectorForEnclave_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_GetLogsCollectorForEnclave_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID) (*logs_collector.LogsCollector, error)) *MockKurtosisBackend_GetLogsCollectorForEnclave_Call {
	_c.Call.Return(run)
	return _c
}

// GetShellOnUserService provides a mock function with given fields: ctx, enclaveUuid, serviceUuid
func (_m *MockKurtosisBackend) GetShellOnUserService(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID) error {
	ret := _m.Called(ctx, enclaveUuid, serviceUuid)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID) error); ok {
		r0 = rf(ctx, enclaveUuid, serviceUuid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_GetShellOnUserService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShellOnUserService'
type MockKurtosisBackend_GetShellOnUserService_Call struct {
	*mock.Call
}

// GetShellOnUserService is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - serviceUuid service.ServiceUUID
func (_e *MockKurtosisBackend_Expecter) GetShellOnUserService(ctx interface{}, enclaveUuid interface{}, serviceUuid interface{}) *MockKurtosisBackend_GetShellOnUserService_Call {
	return &MockKurtosisBackend_GetShellOnUserService_Call{Call: _e.mock.On("GetShellOnUserService", ctx, enclaveUuid, serviceUuid)}
}

func (_c *MockKurtosisBackend_GetShellOnUserService_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID)) *MockKurtosisBackend_GetShellOnUserService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(service.ServiceUUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetShellOnUserService_Call) Return(resultErr error) *MockKurtosisBackend_GetShellOnUserService_Call {
	_c.Call.Return(resultErr)
	return _c
}

func (_c *MockKurtosisBackend_GetShellOnUserService_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, service.ServiceUUID) error) *MockKurtosisBackend_GetShellOnUserService_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserServiceLogs provides a mock function with given fields: ctx, enclaveUuid, filters, shouldFollowLogs
func (_m *MockKurtosisBackend) GetUserServiceLogs(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters, shouldFollowLogs bool) (map[service.ServiceUUID]io.ReadCloser, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, filters, shouldFollowLogs)

	var r0 map[service.ServiceUUID]io.ReadCloser
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) (map[service.ServiceUUID]io.ReadCloser, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) map[service.ServiceUUID]io.ReadCloser); ok {
		r0 = rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) error); ok {
		r2 = rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_GetUserServiceLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserServiceLogs'
type MockKurtosisBackend_GetUserServiceLogs_Call struct {
	*mock.Call
}

// GetUserServiceLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - filters *service.ServiceFilters
//   - shouldFollowLogs bool
func (_e *MockKurtosisBackend_Expecter) GetUserServiceLogs(ctx interface{}, enclaveUuid interface{}, filters interface{}, shouldFollowLogs interface{}) *MockKurtosisBackend_GetUserServiceLogs_Call {
	return &MockKurtosisBackend_GetUserServiceLogs_Call{Call: _e.mock.On("GetUserServiceLogs", ctx, enclaveUuid, filters, shouldFollowLogs)}
}

func (_c *MockKurtosisBackend_GetUserServiceLogs_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters, shouldFollowLogs bool)) *MockKurtosisBackend_GetUserServiceLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(*service.ServiceFilters), args[3].(bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetUserServiceLogs_Call) Return(successfulUserServiceLogs map[service.ServiceUUID]io.ReadCloser, erroredUserServiceUuids map[service.ServiceUUID]error, resultError error) *MockKurtosisBackend_GetUserServiceLogs_Call {
	_c.Call.Return(successfulUserServiceLogs, erroredUserServiceUuids, resultError)
	return _c
}

func (_c *MockKurtosisBackend_GetUserServiceLogs_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) (map[service.ServiceUUID]io.ReadCloser, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_GetUserServiceLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserServices provides a mock function with given fields: ctx, enclaveUuid, filters
func (_m *MockKurtosisBackend) GetUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters) (map[service.ServiceUUID]*service.Service, error) {
	ret := _m.Called(ctx, enclaveUuid, filters)

	var r0 map[service.ServiceUUID]*service.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]*service.Service, error)); ok {
		return rf(ctx, enclaveUuid, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]*service.Service); ok {
		r0 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*service.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) error); ok {
		r1 = rf(ctx, enclaveUuid, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserServices'
type MockKurtosisBackend_GetUserServices_Call struct {
	*mock.Call
}

// GetUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - filters *service.ServiceFilters
func (_e *MockKurtosisBackend_Expecter) GetUserServices(ctx interface{}, enclaveUuid interface{}, filters interface{}) *MockKurtosisBackend_GetUserServices_Call {
	return &MockKurtosisBackend_GetUserServices_Call{Call: _e.mock.On("GetUserServices", ctx, enclaveUuid, filters)}
}

func (_c *MockKurtosisBackend_GetUserServices_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters)) *MockKurtosisBackend_GetUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(*service.ServiceFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetUserServices_Call) Return(_a0 map[service.ServiceUUID]*service.Service, _a1 error) *MockKurtosisBackend_GetUserServices_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_GetUserServices_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]*service.Service, error)) *MockKurtosisBackend_GetUserServices_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUnusedImages provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) PruneUnusedImages(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_PruneUnusedImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUnusedImages'
type MockKurtosisBackend_PruneUnusedImages_Call struct {
	*mock.Call
}

// PruneUnusedImages is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) PruneUnusedImages(ctx interface{}) *MockKurtosisBackend_PruneUnusedImages_Call {
	return &MockKurtosisBackend_PruneUnusedImages_Call{Call: _e.mock.On("PruneUnusedImages", ctx)}
}

func (_c *MockKurtosisBackend_PruneUnusedImages_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_PruneUnusedImages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_PruneUnusedImages_Call) Return(_a0 []string, _a1 error) *MockKurtosisBackend_PruneUnusedImages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKurtosisBackend_PruneUnusedImages_Call) RunAndReturn(run func(context.Context) ([]string, error)) *MockKurtosisBackend_PruneUnusedImages_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterUserServices provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) RegisterUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceName]bool) (map[service.ServiceName]*service.ServiceRegistration, map[service.ServiceName]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceName]*service.ServiceRegistration
	var r1 map[service.ServiceName]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) (map[service.ServiceName]*service.ServiceRegistration, map[service.ServiceName]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) map[service.ServiceName]*service.ServiceRegistration); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceName]*service.ServiceRegistration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) map[service.ServiceName]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceName]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RegisterUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUserServices'
type MockKurtosisBackend_RegisterUserServices_Call struct {
	*mock.Call
}

// RegisterUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - services map[service.ServiceName]bool
func (_e *MockKurtosisBackend_Expecter) RegisterUserServices(ctx interface{}, enclaveUuid interface{}, services interface{}) *MockKurtosisBackend_RegisterUserServices_Call {
	return &MockKurtosisBackend_RegisterUserServices_Call{Call: _e.mock.On("RegisterUserServices", ctx, enclaveUuid, services)}
}

func (_c *MockKurtosisBackend_RegisterUserServices_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceName]bool)) *MockKurtosisBackend_RegisterUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(map[service.ServiceName]bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_RegisterUserServices_Call) Return(_a0 map[service.ServiceName]*service.ServiceRegistration, _a1 map[service.ServiceName]error, _a2 error) *MockKurtosisBackend_RegisterUserServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockKurtosisBackend_RegisterUserServices_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) (map[service.ServiceName]*service.ServiceRegistration, map[service.ServiceName]error, error)) *MockKurtosisBackend_RegisterUserServices_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRegisteredUserServiceProcesses provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) RemoveRegisteredUserServiceProcesses(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRegisteredUserServiceProcesses'
type MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call struct {
	*mock.Call
}

// RemoveRegisteredUserServiceProcesses is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - services map[service.ServiceUUID]bool
func (_e *MockKurtosisBackend_Expecter) RemoveRegisteredUserServiceProcesses(ctx interface{}, enclaveUuid interface{}, services interface{}) *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call {
	return &MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call{Call: _e.mock.On("RemoveRegisteredUserServiceProcesses", ctx, enclaveUuid, services)}
}

func (_c *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]bool)) *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(map[service.ServiceUUID]bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call) Return(_a0 map[service.ServiceUUID]bool, _a1 map[service.ServiceUUID]error, _a2 error) *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_RemoveRegisteredUserServiceProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// RunUserServiceExecCommandWithStreamedOutput provides a mock function with given fields: ctx, enclaveUuid, serviceUuid, cmd
func (_m *MockKurtosisBackend) RunUserServiceExecCommandWithStreamedOutput(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID, cmd []string) (chan string, chan *exec_result.ExecResult, error) {
	ret := _m.Called(ctx, enclaveUuid, serviceUuid, cmd)

	var r0 chan string
	var r1 chan *exec_result.ExecResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, []string) (chan string, chan *exec_result.ExecResult, error)); ok {
		return rf(ctx, enclaveUuid, serviceUuid, cmd)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, []string) chan string); ok {
		r0 = rf(ctx, enclaveUuid, serviceUuid, cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, []string) chan *exec_result.ExecResult); ok {
		r1 = rf(ctx, enclaveUuid, serviceUuid, cmd)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan *exec_result.ExecResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, []string) error); ok {
		r2 = rf(ctx, enclaveUuid, serviceUuid, cmd)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunUserServiceExecCommandWithStreamedOutput'
type MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call struct {
	*mock.Call
}

// RunUserServiceExecCommandWithStreamedOutput is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - serviceUuid service.ServiceUUID
//   - cmd []string
func (_e *MockKurtosisBackend_Expecter) RunUserServiceExecCommandWithStreamedOutput(ctx interface{}, enclaveUuid interface{}, serviceUuid interface{}, cmd interface{}) *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call {
	return &MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call{Call: _e.mock.On("RunUserServiceExecCommandWithStreamedOutput", ctx, enclaveUuid, serviceUuid, cmd)}
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID, cmd []string)) *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(service.ServiceUUID), args[3].([]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call) Return(execOutputChan chan string, finalExecResultChan chan *exec_result.ExecResult, resultErr error) *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call {
	_c.Call.Return(execOutputChan, finalExecResultChan, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, []string) (chan string, chan *exec_result.ExecResult, error)) *MockKurtosisBackend_RunUserServiceExecCommandWithStreamedOutput_Call {
	_c.Call.Return(run)
	return _c
}

// RunUserServiceExecCommands provides a mock function with given fields: ctx, enclaveUuid, userServiceCommands
func (_m *MockKurtosisBackend) RunUserServiceExecCommands(ctx context.Context, enclaveUuid enclave.EnclaveUUID, userServiceCommands map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, userServiceCommands)

	var r0 map[service.ServiceUUID]*exec_result.ExecResult
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, userServiceCommands)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) map[service.ServiceUUID]*exec_result.ExecResult); ok {
		r0 = rf(ctx, enclaveUuid, userServiceCommands)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*exec_result.ExecResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, userServiceCommands)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) error); ok {
		r2 = rf(ctx, enclaveUuid, userServiceCommands)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RunUserServiceExecCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunUserServiceExecCommands'
type MockKurtosisBackend_RunUserServiceExecCommands_Call struct {
	*mock.Call
}

// RunUserServiceExecCommands is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - userServiceCommands map[service.ServiceUUID][]string
func (_e *MockKurtosisBackend_Expecter) RunUserServiceExecCommands(ctx interface{}, enclaveUuid interface{}, userServiceCommands interface{}) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	return &MockKurtosisBackend_RunUserServiceExecCommands_Call{Call: _e.mock.On("RunUserServiceExecCommands", ctx, enclaveUuid, userServiceCommands)}
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommands_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, userServiceCommands map[service.ServiceUUID][]string)) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(map[service.ServiceUUID][]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommands_Call) Return(succesfulUserServiceExecResults map[service.ServiceUUID]*exec_result.ExecResult, erroredUserServiceUuids map[service.ServiceUUID]error, resultErr error) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	_c.Call.Return(succesfulUserServiceExecResults, erroredUserServiceUuids, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommands_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	_c.Call.Return(run)
	return _c
}

// StartRegisteredUserServices provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) StartRegisteredUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]*service.ServiceConfig) (map[service.ServiceUUID]*service.Service, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceUUID]*service.Service
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) (map[service.ServiceUUID]*service.Service, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) map[service.ServiceUUID]*service.Service); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*service.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StartRegisteredUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartRegisteredUserServices'
type MockKurtosisBackend_StartRegisteredUserServices_Call struct {
	*mock.Call
}

// StartRegisteredUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - services map[service.ServiceUUID]*service.ServiceConfig
func (_e *MockKurtosisBackend_Expecter) StartRegisteredUserServices(ctx interface{}, enclaveUuid interface{}, services interface{}) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	return &MockKurtosisBackend_StartRegisteredUserServices_Call{Call: _e.mock.On("StartRegisteredUserServices", ctx, enclaveUuid, services)}
}

func (_c *MockKurtosisBackend_StartRegisteredUserServices_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]*service.ServiceConfig)) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(map[service.ServiceUUID]*service.ServiceConfig))
	})
	return _c
}

func (_c *MockKurtosisBackend_StartRegisteredUserServices_Call) Return(_a0 map[service.ServiceUUID]*service.Service, _a1 map[service.ServiceUUID]error, _a2 error) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockKurtosisBackend_StartRegisteredUserServices_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) (map[service.ServiceUUID]*service.Service, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	_c.Call.Return(run)
	return _c
}

// StopAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopAPIContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopAPIContainers'
type MockKurtosisBackend_StopAPIContainers_Call struct {
	*mock.Call
}

// StopAPIContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *api_container.APIContainerFilters
func (_e *MockKurtosisBackend_Expecter) StopAPIContainers(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopAPIContainers_Call {
	return &MockKurtosisBackend_StopAPIContainers_Call{Call: _e.mock.On("StopAPIContainers", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopAPIContainers_Call) Run(run func(ctx context.Context, filters *api_container.APIContainerFilters)) *MockKurtosisBackend_StopAPIContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api_container.APIContainerFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopAPIContainers_Call) Return(successfulApiContainerIds map[enclave.EnclaveUUID]bool, erroredApiContainerIds map[enclave.EnclaveUUID]error, resultErr error) *MockKurtosisBackend_StopAPIContainers_Call {
	_c.Call.Return(successfulApiContainerIds, erroredApiContainerIds, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_StopAPIContainers_Call) RunAndReturn(run func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)) *MockKurtosisBackend_StopAPIContainers_Call {
	_c.Call.Return(run)
	return _c
}

// StopEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopEnclaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopEnclaves'
type MockKurtosisBackend_StopEnclaves_Call struct {
	*mock.Call
}

// StopEnclaves is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *enclave.EnclaveFilters
func (_e *MockKurtosisBackend_Expecter) StopEnclaves(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopEnclaves_Call {
	return &MockKurtosisBackend_StopEnclaves_Call{Call: _e.mock.On("StopEnclaves", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopEnclaves_Call) Run(run func(ctx context.Context, filters *enclave.EnclaveFilters)) *MockKurtosisBackend_StopEnclaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*enclave.EnclaveFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopEnclaves_Call) Return(successfulEnclaveIds map[enclave.EnclaveUUID]bool, erroredEnclaveIds map[enclave.EnclaveUUID]error, resultErr error) *MockKurtosisBackend_StopEnclaves_Call {
	_c.Call.Return(successfulEnclaveIds, erroredEnclaveIds, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_StopEnclaves_Call) RunAndReturn(run func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)) *MockKurtosisBackend_StopEnclaves_Call {
	_c.Call.Return(run)
	return _c
}

// StopEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]bool
	var r1 map[engine.EngineGUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[engine.EngineGUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *engine.EngineFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopEngines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopEngines'
type MockKurtosisBackend_StopEngines_Call struct {
	*mock.Call
}

// StopEngines is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *engine.EngineFilters
func (_e *MockKurtosisBackend_Expecter) StopEngines(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopEngines_Call {
	return &MockKurtosisBackend_StopEngines_Call{Call: _e.mock.On("StopEngines", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopEngines_Call) Run(run func(ctx context.Context, filters *engine.EngineFilters)) *MockKurtosisBackend_StopEngines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*engine.EngineFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopEngines_Call) Return(successfulEngineGuids map[engine.EngineGUID]bool, erroredEngineGuids map[engine.EngineGUID]error, resultErr error) *MockKurtosisBackend_StopEngines_Call {
	_c.Call.Return(successfulEngineGuids, erroredEngineGuids, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_StopEngines_Call) RunAndReturn(run func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error)) *MockKurtosisBackend_StopEngines_Call {
	_c.Call.Return(run)
	return _c
}

// StopUserServices provides a mock function with given fields: ctx, enclaveUuid, filters
func (_m *MockKurtosisBackend) StopUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, filters)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) error); ok {
		r2 = rf(ctx, enclaveUuid, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopUserServices'
type MockKurtosisBackend_StopUserServices_Call struct {
	*mock.Call
}

// StopUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - filters *service.ServiceFilters
func (_e *MockKurtosisBackend_Expecter) StopUserServices(ctx interface{}, enclaveUuid interface{}, filters interface{}) *MockKurtosisBackend_StopUserServices_Call {
	return &MockKurtosisBackend_StopUserServices_Call{Call: _e.mock.On("StopUserServices", ctx, enclaveUuid, filters)}
}

func (_c *MockKurtosisBackend_StopUserServices_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters)) *MockKurtosisBackend_StopUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(*service.ServiceFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopUserServices_Call) Return(successfulUserServiceUuids map[service.ServiceUUID]bool, erroredUserServiceUuids map[service.ServiceUUID]error, resultErr error) *MockKurtosisBackend_StopUserServices_Call {
	_c.Call.Return(successfulUserServiceUuids, erroredUserServiceUuids, resultErr)
	return _c
}

func (_c *MockKurtosisBackend_StopUserServices_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_StopUserServices_Call {
	_c.Call.Return(run)
	return _c
}

// UnregisterUserServices provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) UnregisterUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_UnregisterUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterUserServices'
type MockKurtosisBackend_UnregisterUserServices_Call struct {
	*mock.Call
}

// UnregisterUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - services map[service.ServiceUUID]bool
func (_e *MockKurtosisBackend_Expecter) UnregisterUserServices(ctx interface{}, enclaveUuid interface{}, services interface{}) *MockKurtosisBackend_UnregisterUserServices_Call {
	return &MockKurtosisBackend_UnregisterUserServices_Call{Call: _e.mock.On("UnregisterUserServices", ctx, enclaveUuid, services)}
}

func (_c *MockKurtosisBackend_UnregisterUserServices_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]bool)) *MockKurtosisBackend_UnregisterUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(map[service.ServiceUUID]bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_UnregisterUserServices_Call) Return(_a0 map[service.ServiceUUID]bool, _a1 map[service.ServiceUUID]error, _a2 error) *MockKurtosisBackend_UnregisterUserServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockKurtosisBackend_UnregisterUserServices_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)) *MockKurtosisBackend_UnregisterUserServices_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEnclave provides a mock function with given fields: ctx, enclaveUuid, newName, creationTime
func (_m *MockKurtosisBackend) UpdateEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, newName string, creationTime *time.Time) error {
	ret := _m.Called(ctx, enclaveUuid, newName, creationTime)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string, *time.Time) error); ok {
		r0 = rf(ctx, enclaveUuid, newName, creationTime)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_UpdateEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEnclave'
type MockKurtosisBackend_UpdateEnclave_Call struct {
	*mock.Call
}

// UpdateEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveUuid enclave.EnclaveUUID
//   - newName string
//   - creationTime *time.Time
func (_e *MockKurtosisBackend_Expecter) UpdateEnclave(ctx interface{}, enclaveUuid interface{}, newName interface{}, creationTime interface{}) *MockKurtosisBackend_UpdateEnclave_Call {
	return &MockKurtosisBackend_UpdateEnclave_Call{Call: _e.mock.On("UpdateEnclave", ctx, enclaveUuid, newName, creationTime)}
}

func (_c *MockKurtosisBackend_UpdateEnclave_Call) Run(run func(ctx context.Context, enclaveUuid enclave.EnclaveUUID, newName string, creationTime *time.Time)) *MockKurtosisBackend_UpdateEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveUUID), args[2].(string), args[3].(*time.Time))
	})
	return _c
}

func (_c *MockKurtosisBackend_UpdateEnclave_Call) Return(_a0 error) *MockKurtosisBackend_UpdateEnclave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKurtosisBackend_UpdateEnclave_Call) RunAndReturn(run func(context.Context, enclave.EnclaveUUID, string, *time.Time) error) *MockKurtosisBackend_UpdateEnclave_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockKurtosisBackend interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockKurtosisBackend creates a new instance of MockKurtosisBackend. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockKurtosisBackend(t mockConstructorTestingTNewMockKurtosisBackend) *MockKurtosisBackend {
	mock := &MockKurtosisBackend{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
