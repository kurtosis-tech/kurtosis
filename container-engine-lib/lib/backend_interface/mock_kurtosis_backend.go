// Code generated by mockery v2.29.0. DO NOT EDIT.

package backend_interface

import (
	context "context"

	api_container "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/api_container"

	enclave "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/enclave"

	engine "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/engine"

	exec_result "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/exec_result"

	io "io"

	logs_collector "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/logs_collector"

	logs_database "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/logs_database"

	mock "github.com/stretchr/testify/mock"

	networking_sidecar "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/networking_sidecar"

	service "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/service"
)

// MockKurtosisBackend is an autogenerated mock type for the KurtosisBackend type
type MockKurtosisBackend struct {
	mock.Mock
}

// CopyFilesFromUserService provides a mock function with given fields: ctx, enclaveUuid, serviceUuid, srcPathOnService, output
func (_m *MockKurtosisBackend) CopyFilesFromUserService(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID, srcPathOnService string, output io.Writer) error {
	ret := _m.Called(ctx, enclaveUuid, serviceUuid, srcPathOnService, output)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID, string, io.Writer) error); ok {
		r0 = rf(ctx, enclaveUuid, serviceUuid, srcPathOnService, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateAPIContainer provides a mock function with given fields: ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars
func (_m *MockKurtosisBackend) CreateAPIContainer(ctx context.Context, image string, enclaveUuid enclave.EnclaveUUID, grpcPortNum uint16, enclaveDataVolumeDirpath string, ownIpAddressEnvVar string, customEnvVars map[string]string) (*api_container.APIContainer, error) {
	ret := _m.Called(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)

	var r0 *api_container.APIContainer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) (*api_container.APIContainer, error)); ok {
		return rf(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) *api_container.APIContainer); ok {
		r0 = rf(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api_container.APIContainer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, enclave.EnclaveUUID, uint16, string, string, map[string]string) error); ok {
		r1 = rf(ctx, image, enclaveUuid, grpcPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEnclave provides a mock function with given fields: ctx, enclaveUuid, enclaveName, isPartitioningEnabled
func (_m *MockKurtosisBackend) CreateEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, enclaveName string, isPartitioningEnabled bool) (*enclave.Enclave, error) {
	ret := _m.Called(ctx, enclaveUuid, enclaveName, isPartitioningEnabled)

	var r0 *enclave.Enclave
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string, bool) (*enclave.Enclave, error)); ok {
		return rf(ctx, enclaveUuid, enclaveName, isPartitioningEnabled)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string, bool) *enclave.Enclave); ok {
		r0 = rf(ctx, enclaveUuid, enclaveName, isPartitioningEnabled)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*enclave.Enclave)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, string, bool) error); ok {
		r1 = rf(ctx, enclaveUuid, enclaveName, isPartitioningEnabled)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEngine provides a mock function with given fields: ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars
func (_m *MockKurtosisBackend) CreateEngine(ctx context.Context, imageOrgAndRepo string, imageVersionTag string, grpcPortNum uint16, envVars map[string]string) (*engine.Engine, error) {
	ret := _m.Called(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)

	var r0 *engine.Engine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint16, map[string]string) (*engine.Engine, error)); ok {
		return rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint16, map[string]string) *engine.Engine); ok {
		r0 = rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*engine.Engine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint16, map[string]string) error); ok {
		r1 = rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, envVars)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLogsCollectorForEnclave provides a mock function with given fields: ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber
func (_m *MockKurtosisBackend) CreateLogsCollectorForEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, logsCollectorHttpPortNumber uint16, logsCollectorTcpPortNumber uint16) (*logs_collector.LogsCollector, error) {
	ret := _m.Called(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)

	var r0 *logs_collector.LogsCollector
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, uint16, uint16) (*logs_collector.LogsCollector, error)); ok {
		return rf(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, uint16, uint16) *logs_collector.LogsCollector); ok {
		r0 = rf(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_collector.LogsCollector)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, uint16, uint16) error); ok {
		r1 = rf(ctx, enclaveUuid, logsCollectorHttpPortNumber, logsCollectorTcpPortNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLogsDatabase provides a mock function with given fields: ctx, logsDatabaseHttpPortNumber
func (_m *MockKurtosisBackend) CreateLogsDatabase(ctx context.Context, logsDatabaseHttpPortNumber uint16) (*logs_database.LogsDatabase, error) {
	ret := _m.Called(ctx, logsDatabaseHttpPortNumber)

	var r0 *logs_database.LogsDatabase
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint16) (*logs_database.LogsDatabase, error)); ok {
		return rf(ctx, logsDatabaseHttpPortNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint16) *logs_database.LogsDatabase); ok {
		r0 = rf(ctx, logsDatabaseHttpPortNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_database.LogsDatabase)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint16) error); ok {
		r1 = rf(ctx, logsDatabaseHttpPortNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkingSidecar provides a mock function with given fields: ctx, enclaveUuid, serviceUuid
func (_m *MockKurtosisBackend) CreateNetworkingSidecar(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID) (*networking_sidecar.NetworkingSidecar, error) {
	ret := _m.Called(ctx, enclaveUuid, serviceUuid)

	var r0 *networking_sidecar.NetworkingSidecar
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID) (*networking_sidecar.NetworkingSidecar, error)); ok {
		return rf(ctx, enclaveUuid, serviceUuid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID) *networking_sidecar.NetworkingSidecar); ok {
		r0 = rf(ctx, enclaveUuid, serviceUuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networking_sidecar.NetworkingSidecar)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID) error); ok {
		r1 = rf(ctx, enclaveUuid, serviceUuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DestroyAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DestroyDeprecatedCentralizedLogsResources provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) DestroyDeprecatedCentralizedLogsResources(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DestroyEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DestroyEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]bool
	var r1 map[engine.EngineGUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[engine.EngineGUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *engine.EngineFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DestroyLogsCollectorForEnclave provides a mock function with given fields: ctx, enclaveUuid
func (_m *MockKurtosisBackend) DestroyLogsCollectorForEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID) error {
	ret := _m.Called(ctx, enclaveUuid)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID) error); ok {
		r0 = rf(ctx, enclaveUuid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DestroyLogsDatabase provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) DestroyLogsDatabase(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DestroyNetworkingSidecars provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyNetworkingSidecars(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DestroyUserServices provides a mock function with given fields: ctx, enclaveUuid, filters
func (_m *MockKurtosisBackend) DestroyUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, filters)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) error); ok {
		r2 = rf(ctx, enclaveUuid, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DumpEnclave provides a mock function with given fields: ctx, enclaveUuid, outputDirpath
func (_m *MockKurtosisBackend) DumpEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, outputDirpath string) error {
	ret := _m.Called(ctx, enclaveUuid, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string) error); ok {
		r0 = rf(ctx, enclaveUuid, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DumpKurtosis provides a mock function with given fields: ctx, outputDirpath
func (_m *MockKurtosisBackend) DumpKurtosis(ctx context.Context, outputDirpath string) error {
	ret := _m.Called(ctx, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FetchImage provides a mock function with given fields: ctx, image
func (_m *MockKurtosisBackend) FetchImage(ctx context.Context, image string) error {
	ret := _m.Called(ctx, image)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]*api_container.APIContainer, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]*api_container.APIContainer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]*api_container.APIContainer, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]*api_container.APIContainer); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]*api_container.APIContainer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]*enclave.Enclave, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]*enclave.Enclave
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]*enclave.Enclave, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]*enclave.Enclave); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]*enclave.Enclave)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEngineLogs provides a mock function with given fields: ctx, outputDirpath
func (_m *MockKurtosisBackend) GetEngineLogs(ctx context.Context, outputDirpath string) error {
	ret := _m.Called(ctx, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]*engine.Engine, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]*engine.Engine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]*engine.Engine, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]*engine.Engine); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]*engine.Engine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLogsCollectorForEnclave provides a mock function with given fields: ctx, enclaveUuid
func (_m *MockKurtosisBackend) GetLogsCollectorForEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID) (*logs_collector.LogsCollector, error) {
	ret := _m.Called(ctx, enclaveUuid)

	var r0 *logs_collector.LogsCollector
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID) (*logs_collector.LogsCollector, error)); ok {
		return rf(ctx, enclaveUuid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID) *logs_collector.LogsCollector); ok {
		r0 = rf(ctx, enclaveUuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_collector.LogsCollector)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID) error); ok {
		r1 = rf(ctx, enclaveUuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLogsDatabase provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) GetLogsDatabase(ctx context.Context) (*logs_database.LogsDatabase, error) {
	ret := _m.Called(ctx)

	var r0 *logs_database.LogsDatabase
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*logs_database.LogsDatabase, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *logs_database.LogsDatabase); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_database.LogsDatabase)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkingSidecars provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetNetworkingSidecars(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceUUID]*networking_sidecar.NetworkingSidecar, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[service.ServiceUUID]*networking_sidecar.NetworkingSidecar
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceUUID]*networking_sidecar.NetworkingSidecar, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceUUID]*networking_sidecar.NetworkingSidecar); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*networking_sidecar.NetworkingSidecar)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShellOnUserService provides a mock function with given fields: ctx, enclaveUuid, serviceUuid
func (_m *MockKurtosisBackend) GetShellOnUserService(ctx context.Context, enclaveUuid enclave.EnclaveUUID, serviceUuid service.ServiceUUID) error {
	ret := _m.Called(ctx, enclaveUuid, serviceUuid)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, service.ServiceUUID) error); ok {
		r0 = rf(ctx, enclaveUuid, serviceUuid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetUserServiceLogs provides a mock function with given fields: ctx, enclaveUuid, filters, shouldFollowLogs
func (_m *MockKurtosisBackend) GetUserServiceLogs(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters, shouldFollowLogs bool) (map[service.ServiceUUID]io.ReadCloser, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, filters, shouldFollowLogs)

	var r0 map[service.ServiceUUID]io.ReadCloser
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) (map[service.ServiceUUID]io.ReadCloser, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) map[service.ServiceUUID]io.ReadCloser); ok {
		r0 = rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters, bool) error); ok {
		r2 = rf(ctx, enclaveUuid, filters, shouldFollowLogs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetUserServices provides a mock function with given fields: ctx, enclaveUuid, filters
func (_m *MockKurtosisBackend) GetUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters) (map[service.ServiceUUID]*service.Service, error) {
	ret := _m.Called(ctx, enclaveUuid, filters)

	var r0 map[service.ServiceUUID]*service.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]*service.Service, error)); ok {
		return rf(ctx, enclaveUuid, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]*service.Service); ok {
		r0 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*service.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) error); ok {
		r1 = rf(ctx, enclaveUuid, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterUserServices provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) RegisterUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceName]bool) (map[service.ServiceName]*service.ServiceRegistration, map[service.ServiceName]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceName]*service.ServiceRegistration
	var r1 map[service.ServiceName]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) (map[service.ServiceName]*service.ServiceRegistration, map[service.ServiceName]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) map[service.ServiceName]*service.ServiceRegistration); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceName]*service.ServiceRegistration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) map[service.ServiceName]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceName]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceName]bool) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RenameEnclave provides a mock function with given fields: ctx, enclaveUuid, newName
func (_m *MockKurtosisBackend) RenameEnclave(ctx context.Context, enclaveUuid enclave.EnclaveUUID, newName string) error {
	ret := _m.Called(ctx, enclaveUuid, newName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, string) error); ok {
		r0 = rf(ctx, enclaveUuid, newName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunNetworkingSidecarExecCommands provides a mock function with given fields: ctx, enclaveUuid, networkingSidecarsCommands
func (_m *MockKurtosisBackend) RunNetworkingSidecarExecCommands(ctx context.Context, enclaveUuid enclave.EnclaveUUID, networkingSidecarsCommands map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, networkingSidecarsCommands)

	var r0 map[service.ServiceUUID]*exec_result.ExecResult
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, networkingSidecarsCommands)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) map[service.ServiceUUID]*exec_result.ExecResult); ok {
		r0 = rf(ctx, enclaveUuid, networkingSidecarsCommands)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*exec_result.ExecResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, networkingSidecarsCommands)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) error); ok {
		r2 = rf(ctx, enclaveUuid, networkingSidecarsCommands)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunUserServiceExecCommands provides a mock function with given fields: ctx, enclaveUuid, userServiceCommands
func (_m *MockKurtosisBackend) RunUserServiceExecCommands(ctx context.Context, enclaveUuid enclave.EnclaveUUID, userServiceCommands map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, userServiceCommands)

	var r0 map[service.ServiceUUID]*exec_result.ExecResult
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) (map[service.ServiceUUID]*exec_result.ExecResult, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, userServiceCommands)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) map[service.ServiceUUID]*exec_result.ExecResult); ok {
		r0 = rf(ctx, enclaveUuid, userServiceCommands)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*exec_result.ExecResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, userServiceCommands)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID][]string) error); ok {
		r2 = rf(ctx, enclaveUuid, userServiceCommands)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StartRegisteredUserServices provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) StartRegisteredUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]*service.ServiceConfig) (map[service.ServiceUUID]*service.Service, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceUUID]*service.Service
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) (map[service.ServiceUUID]*service.Service, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) map[service.ServiceUUID]*service.Service); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]*service.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]*service.ServiceConfig) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StopAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StopEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveUUID]bool
	var r1 map[enclave.EnclaveUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) (map[enclave.EnclaveUUID]bool, map[enclave.EnclaveUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StopEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]bool
	var r1 map[engine.EngineGUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[engine.EngineGUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *engine.EngineFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StopNetworkingSidecars provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopNetworkingSidecars(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// StopUserServices provides a mock function with given fields: ctx, enclaveUuid, filters
func (_m *MockKurtosisBackend) StopUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, filters *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, filters)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, *service.ServiceFilters) error); ok {
		r2 = rf(ctx, enclaveUuid, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UnregisterUserServices provides a mock function with given fields: ctx, enclaveUuid, services
func (_m *MockKurtosisBackend) UnregisterUserServices(ctx context.Context, enclaveUuid enclave.EnclaveUUID, services map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error) {
	ret := _m.Called(ctx, enclaveUuid, services)

	var r0 map[service.ServiceUUID]bool
	var r1 map[service.ServiceUUID]error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) (map[service.ServiceUUID]bool, map[service.ServiceUUID]error, error)); ok {
		return rf(ctx, enclaveUuid, services)
	}
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) map[service.ServiceUUID]bool); ok {
		r0 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceUUID]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) map[service.ServiceUUID]error); ok {
		r1 = rf(ctx, enclaveUuid, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceUUID]error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveUUID, map[service.ServiceUUID]bool) error); ok {
		r2 = rf(ctx, enclaveUuid, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

type mockConstructorTestingTNewMockKurtosisBackend interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockKurtosisBackend creates a new instance of MockKurtosisBackend. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockKurtosisBackend(t mockConstructorTestingTNewMockKurtosisBackend) *MockKurtosisBackend {
	mock := &MockKurtosisBackend{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
